<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文件↔图像转换器（黑白Unicode编码）</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00dbde, #fc00ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #a0a0c0;
            margin-bottom: 5px;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .stat-box {
            background: rgba(30, 30, 60, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 100, 200, 0.2);
        }
        
        .card-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3a3a7a;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-title i {
            color: #6c63ff;
        }
        
        .file-upload-area {
            border: 3px dashed #3a3a7a;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            background: rgba(30, 30, 60, 0.5);
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-upload-area:hover {
            border-color: #6c63ff;
            background: rgba(60, 60, 100, 0.7);
        }
        
        .upload-icon {
            font-size: 3.5rem;
            color: #6c63ff;
            margin-bottom: 15px;
        }
        
        .file-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.95rem;
        }
        
        .file-info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .file-info-row:last-child {
            border-bottom: none;
        }
        
        .file-info-label {
            color: #a0a0c0;
        }
        
        .file-info-value {
            color: #ffffff;
            font-weight: 600;
        }
        
        .dimension-controls {
            background: rgba(30, 30, 60, 0.7);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .dimension-controls label {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            min-width: 150px;
        }
        
        .dimension-controls span {
            font-size: 0.9rem;
            color: #a0a0c0;
        }
        
        .dimension-controls input {
            padding: 8px 12px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #3a3a7a;
            border-radius: 4px;
            color: #e0e0e0;
        }
        
        .dimension-controls input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .dimension-controls button {
            padding: 8px 16px;
            background: rgba(60, 60, 100, 0.8);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .dimension-controls button:hover {
            background: rgba(80, 80, 140, 0.8);
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(90deg, #6c63ff, #3a3a7a);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(90deg, #5a52e0, #2a2a5a);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(108, 99, 255, 0.3);
        }
        
        .btn-secondary {
            background: rgba(60, 60, 100, 0.8);
            color: white;
        }
        
        .btn-secondary:hover {
            background: rgba(80, 80, 140, 0.8);
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: linear-gradient(90deg, #4caf50, #2e7d32);
            color: white;
        }
        
        .btn-success:hover:not(:disabled) {
            background: linear-gradient(90deg, #3d8b40, #1b5e20);
            transform: translateY(-2px);
        }
        
        .btn-warning {
            background: linear-gradient(90deg, #ff9800, #f57c00);
            color: white;
        }
        
        .btn-warning:hover {
            background: linear-gradient(90deg, #f57c00, #e65100);
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .canvas-wrapper {
            width: 100%;
            background: rgba(10, 10, 20, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }
        
        canvas {
            max-width: 100%;
            max-height: 400px;
            border: 1px solid #3a3a7a;
            border-radius: 4px;
            background-color: white;
        }
        
        .image-placeholder {
            width: 100%;
            height: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #8888aa;
            border: 2px dashed #3a3a7a;
            border-radius: 8px;
        }
        
        .image-placeholder i {
            font-size: 3rem;
            margin-bottom: 15px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-label {
            display: block;
            padding: 12px 24px;
            background: rgba(60, 60, 100, 0.8);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-label:hover {
            background: rgba(80, 80, 140, 0.8);
        }
        
        .result-box {
            margin-top: 20px;
            padding: 15px;
            background: rgba(10, 10, 20, 0.8);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            border: 1px solid #3a3a7a;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #6c63ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info-box {
            grid-column: 1 / -1;
            margin-top: 20px;
            background: rgba(30, 30, 60, 0.7);
            border-left: 4px solid #6c63ff;
        }
        
        .info-box h3 {
            margin-bottom: 10px;
            color: #a0a0ff;
        }
        
        .info-box ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }
        
        .info-box li {
            margin-bottom: 5px;
        }
        
        .image-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #a0a0c0;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .size-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }
        
        .unicode-badge {
            background: rgba(33, 150, 243, 0.2);
            color: #2196f3;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid rgba(100, 100, 200, 0.2);
            color: #8888aa;
            font-size: 0.9rem;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background: rgba(40, 40, 80, 0.95);
            border-radius: 8px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.4s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification.success {
            border-left: 4px solid #4caf50;
        }
        
        .notification.error {
            border-left: 4px solid #ff5252;
        }
        
        .notification.info {
            border-left: 4px solid #2196f3;
        }
        
        .notification.warning {
            border-left: 4px solid #ff9800;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(60, 60, 100, 0.8);
            border-radius: 13px;
            margin-right: 10px;
            transition: background 0.3s;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 11px;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        
        .toggle-checkbox:checked + .toggle-switch {
            background: #6c63ff;
        }
        
        .toggle-checkbox:checked + .toggle-switch::after {
            transform: translateX(24px);
        }
        
        .toggle-checkbox {
            display: none;
        }
        
        .encoding-info {
            background: rgba(30, 30, 60, 0.7);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #a0a0c0;
            border-left: 3px solid #6c63ff;
            margin-bottom: 15px;
        }
        
        .bits-info {
            background: rgba(30, 30, 60, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.85rem;
        }
        
        .bits-info span {
            font-family: monospace;
            color: #6c63ff;
            font-weight: bold;
        }
        
        .char-count {
            text-align: right;
            margin-bottom: 15px;
            font-size: 0.9rem;
            color: #a0a0c0;
        }
        
        .char-count.warning {
            color: #ff9800;
        }
        
        .char-count.error {
            color: #ff5252;
        }
        
        .preview-text {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            display: none;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: #b0d4e0;
        }
        
        .header-marker {
            background: rgba(108, 99, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8rem;
        }
        
        @media (max-width: 768px) {
            .stats {
                flex-direction: column;
                align-items: center;
            }
            
            .dimension-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-file-image"></i> 文件↔图像转换器（黑白Unicode编码）</h1>
            <p class="subtitle">将任意文件编码为黑白图像，支持Unicode编码（21位/字符）</p>
            <div class="stats">
                <div class="stat-box">编码模式: Unicode 21位/字符</div>
                <div class="stat-box">像素类型: 黑白（1位/像素）</div>
                <div class="stat-box">支持文件: 任意类型</div>
            </div>
        </header>
        
        <div class="main-content">
            <!-- 编码部分 -->
            <div class="card">
                <h2 class="card-title"><i class="fas fa-lock"></i> 编码文件到图像</h2>
                
                <!-- 编码信息 -->
                <div class="encoding-info">
                    <i class="fas fa-info-circle"></i> 
                    Unicode编码模式：每个字符使用21位二进制编码，支持所有Unicode字符和任意文件类型
                </div>
                
                <!-- 文件上传区域 -->
                <div id="fileUploadArea" class="file-upload-area">
                    <div class="upload-icon">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <h3>点击或拖放文件到此区域</h3>
                    <p>支持任意文件类型：图片、文档、压缩包、视频等</p>
                    <input type="file" id="fileInput" style="display: none;">
                </div>
                
                <!-- 文件信息 -->
                <div id="fileInfo" class="file-info" style="display: none;">
                    <div class="file-info-row">
                        <span class="file-info-label">文件名：</span>
                        <span id="fileName" class="file-info-value">未选择文件</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">文件大小：</span>
                        <span id="fileSize" class="file-info-value">0 KB</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">文件类型：</span>
                        <span id="fileType" class="file-info-value">未知</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">数据头部：</span>
                        <span id="fileHeader" class="file-info-value">待生成</span>
                    </div>
                </div>
                
                <!-- 字节预览 -->
                <div id="bytesPreviewContainer" class="preview-text">
                    <div class="preview-header">
                        <span>文件字节预览（前1000字节）：</span>
                        <span id="bytesPreviewLength">0 字节</span>
                    </div>
                    <div id="bytesPreview"></div>
                </div>
                
                <!-- 自动尺寸切换 -->
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="autoSizeToggle" class="toggle-checkbox" checked>
                        <span class="toggle-switch"></span>
                        <span>自动调整图像尺寸</span>
                    </label>
                    <span id="toggleStatus" class="size-badge unicode-badge">已启用</span>
                </div>
                
                <!-- 图像尺寸控制 -->
                <div id="dimensionControls" class="dimension-controls" style="display: none;">
                    <label>
                        <span>图像宽度:</span>
                        <input type="number" id="imageWidth" min="100" max="10000" value="980">
                    </label>
                    <label>
                        <span>图像高度:</span>
                        <input type="number" id="imageHeight" min="142" max="10000" value="1400">
                    </label>
                    <label>
                        <span>宽高比:</span>
                        <input type="text" id="aspectRatio" value="1:1.43" disabled>
                    </label>
                    <button id="calculateDimensionsBtn">
                        <i class="fas fa-calculator"></i> 计算尺寸
                    </button>
                </div>
                
                <!-- 字符计数和位信息 -->
                <div class="char-count" id="charCount">总字符数: 0 (0像素)</div>
                <div id="bitsInfo" class="bits-info" style="display: none;">
                    <i class="fas fa-microchip"></i> 总位数: <span id="totalBits">0</span> 位 | 每个字符: <span id="bitsPerChar">21</span> 位
                </div>
                
                <!-- 按钮组 -->
                <div class="button-group">
                    <button id="encodeBtn" class="btn btn-primary" disabled>
                        <i class="fas fa-cogs"></i> 编码为图像
                    </button>
                    <button id="clearInputBtn" class="btn btn-secondary">
                        <i class="fas fa-trash-alt"></i> 清空输入
                    </button>
                </div>
                
                <!-- 图像输出 -->
                <div class="canvas-wrapper">
                    <div id="imageOutput" class="image-placeholder">
                        <i class="fas fa-image"></i>
                        <p>编码后的图像将在这里显示</p>
                    </div>
                    <canvas id="encodedCanvas"></canvas>
                </div>
                
                <div class="image-info">
                    <div id="imageDimensions">图像尺寸: 未生成</div>
                    <div id="imageSize">文件大小: 未生成</div>
                    <div id="encodingModeIndicator">编码模式: Unicode</div>
                </div>
                
                <button id="downloadBtn" class="btn btn-success" disabled style="margin-top: 10px;">
                    <i class="fas fa-download"></i> 下载图像
                </button>
            </div>
            
            <!-- 解码部分 -->
            <div class="card">
                <h2 class="card-title"><i class="fas fa-unlock"></i> 从图像解码文件</h2>
                
                <div class="encoding-info">
                    <i class="fas fa-info-circle"></i> 
                    请上传之前编码生成的图像。系统会自动识别编码模式并提取文件。
                </div>
                
                <!-- 图像上传 -->
                <div class="file-input-wrapper" style="margin-bottom: 20px;">
                    <div class="file-input-label">
                        <i class="fas fa-upload"></i> 选择编码图像（PNG格式）
                    </div>
                    <input type="file" id="imageInput" accept="image/png">
                </div>
                
                <!-- 解码信息 -->
                <div id="decodeInfo" class="file-info" style="display: none;">
                    <div class="file-info-row">
                        <span class="file-info-label">检测到文件：</span>
                        <span id="detectedFileName" class="file-info-value">未识别</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">文件大小：</span>
                        <span id="detectedFileSize" class="file-info-value">0 KB</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">头部标识：</span>
                        <span id="detectedHeader" class="file-info-value">未识别</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">图像尺寸：</span>
                        <span id="detectedImageSize" class="file-info-value">0×0 像素</span>
                    </div>
                </div>
                
                <!-- 解码图像预览 -->
                <div class="canvas-wrapper">
                    <div id="decodedImagePlaceholder" class="image-placeholder">
                        <i class="fas fa-image"></i>
                        <p>上传的图像将在这里预览</p>
                    </div>
                    <canvas id="decodedCanvas"></canvas>
                </div>
                
                <!-- 按钮组 -->
                <div class="button-group">
                    <button id="decodeBtn" class="btn btn-primary" disabled>
                        <i class="fas fa-search"></i> 解码图像
                    </button>
                    <button id="clearOutputBtn" class="btn btn-secondary">
                        <i class="fas fa-trash-alt"></i> 清空
                    </button>
                </div>
                
                <!-- 字节预览 -->
                <div id="decodedBytesContainer" class="preview-text">
                    <div class="preview-header">
                        <span>解码字节预览（前1000字节）：</span>
                        <span id="decodedBytesLength">0 字节</span>
                    </div>
                    <div id="decodedBytesPreview"></div>
                </div>
                
                <!-- 下载按钮 -->
                <button id="downloadFileBtn" class="btn btn-success" disabled style="margin-top: 10px;">
                    <i class="fas fa-download"></i> 下载解码文件
                </button>
            </div>
            
            <!-- 算法说明 -->
            <div class="card info-box">
                <h3><i class="fas fa-calculator"></i> 编码算法说明</h3>
                <ul>
                    <li><strong>数据格式</strong>：
                        <ul>
                            <li>头部标识：<span class="header-marker">FIMG|</span> (固定5字符)</li>
                            <li>文件名长度：4字节（32位）整数</li>
                            <li>文件名：原文件名（Unicode编码）</li>
                            <li>文件数据长度：4字节（32位）整数</li>
                            <li>文件数据：原始二进制字节数据</li>
                        </ul>
                    </li>
                    <li><strong>编码过程</strong>：
                        <ul>
                            <li>1. 读取文件的原始二进制数据</li>
                            <li>2. 构建完整数据：头部 + 文件名长度 + 文件名 + 数据长度 + 原始数据</li>
                            <li>3. 每个字符转换为21位二进制（Unicode编码）</li>
                            <li>4. 每个二进制位对应一个像素（0=白色，1=黑色）</li>
                        </ul>
                    </li>
                    <li><strong>解码过程</strong>：
                        <ul>
                            <li>1. 从图像中读取黑白像素，转换为二进制位</li>
                            <li>2. 每21位转换为一个Unicode字符</li>
                            <li>3. 识别头部标识，提取文件名和文件数据</li>
                            <li>4. 将二进制数据转换回原始文件</li>
                        </ul>
                    </li>
                    <li><strong>技术参数</strong>：
                        <ul>
                            <li>每个字符：21位二进制编码</li>
                            <li>每个像素：1位（黑白）</li>
                            <li>支持最大Unicode码点：0x10FFFF</li>
                            <li>图像宽高比：接近A4比例（1:1.414）</li>
                            <li>直接使用原始二进制数据，无Base64转换</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        
        <!-- 加载指示器 -->
        <div id="loadingIndicator" class="loading">
            <div class="spinner"></div>
            <p>正在处理中，请稍候...</p>
        </div>
        
        <footer>
            <p>文件↔图像转换器（黑白Unicode编码） | 支持任意文件类型 | 每个字符21位 | 黑白像素编码 | 直接二进制处理</p>
            <p>© 2023 文件图像转换工具 | 基于Unicode编码标准</p>
        </footer>
    </div>
    
    <!-- 通知 -->
    <div id="notification" class="notification">
        <i id="notificationIcon" class="fas fa-info-circle"></i>
        <span id="notificationMessage">这是一条通知</span>
    </div>

    <script>
        // ============== DOM元素 ==============
        const fileInput = document.getElementById('fileInput');
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const fileType = document.getElementById('fileType');
        const fileHeader = document.getElementById('fileHeader');
        
        const bytesPreviewContainer = document.getElementById('bytesPreviewContainer');
        const bytesPreview = document.getElementById('bytesPreview');
        const bytesPreviewLength = document.getElementById('bytesPreviewLength');
        
        const charCount = document.getElementById('charCount');
        const encodeBtn = document.getElementById('encodeBtn');
        const clearInputBtn = document.getElementById('clearInputBtn');
        const encodedCanvas = document.getElementById('encodedCanvas');
        const imageOutput = document.getElementById('imageOutput');
        const downloadBtn = document.getElementById('downloadBtn');
        const imageInput = document.getElementById('imageInput');
        const decodeBtn = document.getElementById('decodeBtn');
        const clearOutputBtn = document.getElementById('clearOutputBtn');
        const downloadFileBtn = document.getElementById('downloadFileBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const notification = document.getElementById('notification');
        const notificationIcon = document.getElementById('notificationIcon');
        const notificationMessage = document.getElementById('notificationMessage');
        
        const autoSizeToggle = document.getElementById('autoSizeToggle');
        const dimensionControls = document.getElementById('dimensionControls');
        const imageWidthInput = document.getElementById('imageWidth');
        const imageHeightInput = document.getElementById('imageHeight');
        const aspectRatioInput = document.getElementById('aspectRatio');
        const calculateDimensionsBtn = document.getElementById('calculateDimensionsBtn');
        const toggleStatus = document.getElementById('toggleStatus');
        const imageDimensions = document.getElementById('imageDimensions');
        const imageSize = document.getElementById('imageSize');
        const encodingModeIndicator = document.getElementById('encodingModeIndicator');
        
        const bitsInfo = document.getElementById('bitsInfo');
        const totalBits = document.getElementById('totalBits');
        const bitsPerChar = document.getElementById('bitsPerChar');
        
        const decodeInfo = document.getElementById('decodeInfo');
        const detectedFileName = document.getElementById('detectedFileName');
        const detectedFileSize = document.getElementById('detectedFileSize');
        const detectedHeader = document.getElementById('detectedHeader');
        const detectedImageSize = document.getElementById('detectedImageSize');
        
        const decodedImagePlaceholder = document.getElementById('decodedImagePlaceholder');
        const decodedCanvas = document.getElementById('decodedCanvas');
        const decodedBytesContainer = document.getElementById('decodedBytesContainer');
        const decodedBytesPreview = document.getElementById('decodedBytesPreview');
        const decodedBytesLength = document.getElementById('decodedBytesLength');
        
        // ============== 常量定义 ==============
        const HEADER_MARKER = 'FIMG|'; // 头部标识
        const BITS_PER_CHAR = 21; // Unicode编码每个字符21位
        const MAX_UNICODE = 0x10FFFF; // Unicode最大码点
        const MIN_WIDTH = 100;
        const MIN_HEIGHT = 142;
        const MAX_WIDTH = 10000;
        const MAX_HEIGHT = 14140;
        const ASPECT_RATIO = 1.414; // A4比例
        
        // ============== 状态变量 ==============
        let currentFile = null;
        let fileData = null;
        let autoSizeEnabled = true;
        let currentWidth = 980;
        let currentHeight = 1400;
        let decodedFileInfo = null;
        
        // ============== 初始化 ==============
        document.addEventListener('DOMContentLoaded', function() {
            initializePage();
        });
        
        function initializePage() {
            setupEventListeners();
            updateAspectRatio();
            
            // 初始化canvas样式
            encodedCanvas.style.display = 'none';
            decodedCanvas.style.display = 'none';
            
            // 显示欢迎信息
            setTimeout(() => {
                showNotification('文件↔图像转换器已加载！支持任意文件类型的黑白Unicode编码。', 'info');
            }, 1000);
        }
        
        // ============== 事件监听器设置 ==============
        function setupEventListeners() {
            // 文件上传区域点击
            fileUploadArea.addEventListener('click', () => fileInput.click());
            
            // 文件拖放支持
            fileUploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileUploadArea.style.borderColor = '#6c63ff';
                fileUploadArea.style.background = 'rgba(60, 60, 100, 0.7)';
            });
            
            fileUploadArea.addEventListener('dragleave', () => {
                fileUploadArea.style.borderColor = '#3a3a7a';
                fileUploadArea.style.background = 'rgba(30, 30, 60, 0.5)';
            });
            
            fileUploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                fileUploadArea.style.borderColor = '#3a3a7a';
                fileUploadArea.style.background = 'rgba(30, 30, 60, 0.5)';
                
                if (e.dataTransfer.files.length > 0) {
                    handleFileSelect(e.dataTransfer.files[0]);
                }
            });
            
            // 文件选择
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileSelect(e.target.files[0]);
                }
            });
            
            // 图像上传区域
            imageInput.addEventListener('change', function() {
                decodeBtn.disabled = !this.files.length;
                if (this.files.length > 0) {
                    previewEncodedImage(this.files[0]);
                }
            });
            
            // 自动尺寸切换
            autoSizeToggle.addEventListener('change', function() {
                autoSizeEnabled = this.checked;
                dimensionControls.style.display = autoSizeEnabled ? 'none' : 'flex';
                toggleStatus.textContent = autoSizeEnabled ? '已启用' : '已禁用';
                updateFileInfo();
            });
            
            // 手动尺寸输入
            imageWidthInput.addEventListener('input', function() {
                if (!autoSizeEnabled) {
                    const width = parseInt(this.value) || MIN_WIDTH;
                    const height = Math.round(width * ASPECT_RATIO);
                    imageHeightInput.value = height;
                    updateAspectRatio();
                    updateFileInfo();
                }
            });
            
            imageHeightInput.addEventListener('input', function() {
                if (!autoSizeEnabled) {
                    const height = parseInt(this.value) || MIN_HEIGHT;
                    const width = Math.round(height / ASPECT_RATIO);
                    imageWidthInput.value = width;
                    updateAspectRatio();
                    updateFileInfo();
                }
            });
            
            // 计算尺寸按钮
            calculateDimensionsBtn.addEventListener('click', function() {
                if (!autoSizeEnabled) {
                    const width = parseInt(imageWidthInput.value) || MIN_WIDTH;
                    const height = parseInt(imageHeightInput.value) || MIN_HEIGHT;
                    currentWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, width));
                    currentHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, height));
                    imageWidthInput.value = currentWidth;
                    imageHeightInput.value = currentHeight;
                    updateAspectRatio();
                    updateFileInfo();
                    showNotification(`图像尺寸已设置为 ${currentWidth}×${currentHeight} 像素`, 'info');
                }
            });
            
            // 编码按钮
            encodeBtn.addEventListener('click', encodeFileToImage);
            
            // 清空输入按钮
            clearInputBtn.addEventListener('click', () => {
                clearEncoder();
                showNotification('输入已清空', 'info');
            });
            
            // 下载按钮
            downloadBtn.addEventListener('click', downloadImage);
            
            // 解码按钮
            decodeBtn.addEventListener('click', decodeImageToFile);
            
            // 清空输出按钮
            clearOutputBtn.addEventListener('click', () => {
                clearDecoder();
                showNotification('输出已清空', 'info');
            });
            
            // 下载文件按钮
            downloadFileBtn.addEventListener('click', downloadDecodedFile);
            
            // 设置键盘快捷键
            setupKeyboardShortcuts();
        }
        
        // ============== 清空编码器 ==============
        function clearEncoder() {
            currentFile = null;
            fileData = null;
            fileInput.value = '';
            fileInfo.style.display = 'none';
            bytesPreviewContainer.style.display = 'none';
            imageOutput.style.display = 'flex';
            encodedCanvas.style.display = 'none';
            encodeBtn.disabled = true;
            downloadBtn.disabled = true;
            bitsInfo.style.display = 'none';
            charCount.textContent = '总字符数: 0 (0像素)';
            imageDimensions.textContent = '图像尺寸: 未生成';
            imageSize.textContent = '文件大小: 未生成';
        }
        
        // ============== 清空解码器 ==============
        function clearDecoder() {
            decodedFileInfo = null;
            imageInput.value = '';
            decodeInfo.style.display = 'none';
            decodedBytesContainer.style.display = 'none';
            decodedImagePlaceholder.style.display = 'flex';
            decodedCanvas.style.display = 'none';
            decodeBtn.disabled = true;
            downloadFileBtn.disabled = true;
        }
        
        // ============== 文件选择处理 ==============
        function handleFileSelect(file) {
            currentFile = file;
            
            // 显示文件信息
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileType.textContent = getFileExtension(file.name);
            fileHeader.textContent = HEADER_MARKER;
            
            // 显示文件信息面板
            fileInfo.style.display = 'block';
            
            // 读取文件数据
            const reader = new FileReader();
            reader.onload = function(e) {
                fileData = e.target.result;
                
                // 显示字节预览
                showBytesPreview(new Uint8Array(fileData));
                
                // 更新文件信息
                updateFileInfo();
                
                // 启用编码按钮
                encodeBtn.disabled = false;
            };
            
            reader.onerror = function() {
                showNotification('文件读取失败', 'error');
            };
            
            reader.readAsArrayBuffer(file);
            
            showNotification(`已选择文件：${file.name}`, 'success');
        }
        
        // ============== 显示字节预览 ==============
        function showBytesPreview(bytes) {
            bytesPreviewContainer.style.display = 'block';
            const previewCount = Math.min(bytes.length, 1000);
            bytesPreviewLength.textContent = `${previewCount} 字节 / 总共 ${bytes.length} 字节`;
            
            let previewText = '';
            for (let i = 0; i < previewCount; i++) {
                const byte = bytes[i];
                previewText += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
                if ((i + 1) % 16 === 0) previewText += '\n';
            }
            
            bytesPreview.textContent = previewText;
        }
        
        // ============== 更新文件信息 ==============
        function updateFileInfo() {
            if (!currentFile || !fileData) return;
            
            const bytes = new Uint8Array(fileData);
            const totalChars = calculateTotalChars(currentFile.name, bytes);
            const pixelsNeeded = totalChars * BITS_PER_CHAR;
            
            if (autoSizeEnabled) {
                calculateAutoDimensions(pixelsNeeded);
                charCount.textContent = `总字符数: ${totalChars.toLocaleString()} (${pixelsNeeded.toLocaleString()}像素)`;
                charCount.textContent += ` | 图像尺寸: ${currentWidth}×${currentHeight}`;
            } else {
                currentWidth = parseInt(imageWidthInput.value) || MIN_WIDTH;
                currentHeight = parseInt(imageHeightInput.value) || MIN_HEIGHT;
                const maxPixels = currentWidth * currentHeight;
                const maxChars = Math.floor(maxPixels / BITS_PER_CHAR);
                
                charCount.textContent = `总字符数: ${totalChars.toLocaleString()} (${pixelsNeeded.toLocaleString()}像素)`;
                if (pixelsNeeded > maxPixels) {
                    charCount.classList.add('warning');
                    charCount.textContent += ` (警告: 需要 ${maxChars.toLocaleString()} 字符以内)`;
                } else {
                    charCount.classList.remove('warning');
                }
            }
            
            // 更新位信息
            updateBitsInfo(totalChars);
        }
        
        // ============== 计算总字符数 ==============
        function calculateTotalChars(filename, bytes) {
            // 数据格式：头部(5) + 文件名长度(2字符) + 文件名 + 数据长度(2字符) + 文件数据
            
            // 头部标识
            let total = HEADER_MARKER.length;
            
            // 文件名长度（32位整数，需要2个Unicode字符）
            total += 2;
            
            // 文件名本身
            total += filename.length;
            
            // 数据长度（32位整数，需要2个Unicode字符）
            total += 2;
            
            // 文件数据（每个字节转换为一个字符）
            total += bytes.length;
            
            return total;
        }
        
        // ============== 更新位信息 ==============
        function updateBitsInfo(totalChars) {
            const totalBitsValue = totalChars * BITS_PER_CHAR;
            
            totalBits.textContent = totalBitsValue.toLocaleString();
            bitsPerChar.textContent = BITS_PER_CHAR;
            
            // 显示位信息
            bitsInfo.style.display = totalChars > 0 ? 'block' : 'none';
        }
        
        // ============== Unicode编码函数 ==============
        function encodeUnicodeToBinary(text) {
            // 将字符串中的每个字符编码为21位二进制
            const binaryArray = [];
            
            for (let i = 0; i < text.length; i++) {
                const charCode = text.codePointAt(i);
                
                // 处理代理对（UTF-16代理对）
                if (charCode >= 0xD800 && charCode <= 0xDFFF) {
                    // 跳过代理对的低代理项
                    continue;
                }
                
                // 确保码点在有效范围内
                if (charCode > MAX_UNICODE) {
                    throw new Error(`字符码点 ${charCode} 超出Unicode范围 (最大: ${MAX_UNICODE})`);
                }
                
                // 转换为21位二进制
                let binary = charCode.toString(2);
                
                // 填充到21位
                while (binary.length < BITS_PER_CHAR) {
                    binary = '0' + binary;
                }
                
                // 添加到数组
                for (let bit = 0; bit < BITS_PER_CHAR; bit++) {
                    binaryArray.push(parseInt(binary[bit]));
                }
            }
            
            return binaryArray;
        }
        
        function decodeBinaryToUnicode(binaryArray) {
            // 将21位二进制数组解码为字符串
            let text = '';
            
            for (let i = 0; i < binaryArray.length; i += BITS_PER_CHAR) {
                if (i + BITS_PER_CHAR > binaryArray.length) break;
                
                // 提取21位二进制
                let binary = '';
                for (let j = 0; j < BITS_PER_CHAR; j++) {
                    binary += binaryArray[i + j] || '0';
                }
                
                // 转换为字符代码
                const charCode = parseInt(binary, 2);
                
                // 添加到字符串
                text += String.fromCodePoint(charCode);
            }
            
            return text;
        }
        
        // ============== 计算自动尺寸 ==============
        function calculateAutoDimensions(pixelsNeeded) {
            if (pixelsNeeded <= 0) {
                currentWidth = MIN_WIDTH;
                currentHeight = MIN_HEIGHT;
                return;
            }
            
            // 根据A4比例计算宽度：width = sqrt(pixels / aspectRatio)
            let width = Math.sqrt(pixelsNeeded / ASPECT_RATIO);
            
            // 确保在最小和最大范围内
            width = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, width));
            
            // 计算高度，保持A4比例
            let height = Math.round(width * ASPECT_RATIO);
            
            // 调整高度确保能容纳所有像素
            const totalPixels = width * height;
            if (totalPixels < pixelsNeeded) {
                height = Math.ceil(pixelsNeeded / width);
            }
            
            // 确保高度也在范围内
            height = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, height));
            
            // 再次检查宽度是否需要调整
            if (width * height < pixelsNeeded) {
                width = Math.ceil(pixelsNeeded / height);
                width = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, width));
            }
            
            currentWidth = Math.floor(width);
            currentHeight = Math.floor(height);
        }
        
        // ============== 更新宽高比显示 ==============
        function updateAspectRatio() {
            const width = parseInt(imageWidthInput.value) || MIN_WIDTH;
            const height = parseInt(imageHeightInput.value) || MIN_HEIGHT;
            const ratio = (height / width).toFixed(3);
            aspectRatioInput.value = `1:${ratio}`;
        }
        
        // ============== 编码文件为图像 ==============
        function encodeFileToImage() {
            if (!currentFile || !fileData) {
                showNotification('请先选择文件', 'error');
                return;
            }
            
            // 显示加载指示器
            showLoading(true);
            
            // 使用setTimeout避免阻塞UI
            setTimeout(() => {
                try {
                    const bytes = new Uint8Array(fileData);
                    
                    // 构建完整数据
                    const fullData = buildFileData(currentFile.name, bytes);
                    
                    // 计算图像尺寸
                    const totalChars = fullData.length;
                    const pixelsNeeded = totalChars * BITS_PER_CHAR;
                    
                    if (autoSizeEnabled) {
                        calculateAutoDimensions(pixelsNeeded);
                    } else {
                        currentWidth = parseInt(imageWidthInput.value) || MIN_WIDTH;
                        currentHeight = parseInt(imageHeightInput.value) || MIN_HEIGHT;
                    }
                    
                    // 检查是否能容纳所有数据
                    const totalPixels = currentWidth * currentHeight;
                    if (pixelsNeeded > totalPixels) {
                        throw new Error(`图像太小，无法容纳所有数据。需要至少 ${Math.ceil(pixelsNeeded / currentWidth)} 像素高度。`);
                    }
                    
                    // 设置画布尺寸
                    encodedCanvas.width = currentWidth;
                    encodedCanvas.height = currentHeight;
                    
                    // 将完整数据转换为二进制
                    const binaryArray = encodeUnicodeToBinary(fullData);
                    
                    // 填充剩余的像素为白色
                    while (binaryArray.length < totalPixels) {
                        binaryArray.push(0);
                    }
                    
                    // 创建黑白图像
                    createBinaryImage(binaryArray);
                    
                    // 显示图像
                    displayEncodedImage();
                    
                    // 更新图像信息
                    updateImageInfo();
                    
                    // 启用下载按钮
                    downloadBtn.disabled = false;
                    
                    // 显示编码成功信息
                    const successMessage = `编码成功！文件 "${currentFile.name}" 已编码为 ${currentWidth}×${currentHeight} 像素的黑白图像`;
                    showNotification(successMessage, 'success');
                } catch (error) {
                    console.error('编码错误:', error);
                    showNotification('编码过程中发生错误: ' + error.message, 'error');
                } finally {
                    showLoading(false);
                }
            }, 100);
        }
        
        // ============== 构建文件数据 ==============
        function buildFileData(filename, bytes) {
            // 数据格式：头部标识 + 文件名长度 + 文件名 + 数据长度 + 文件数据
            
            // 头部标识
            let data = HEADER_MARKER;
            
            // 文件名长度（32位整数）
            const filenameLength = filename.length;
            const filenameLengthBinary = encode32BitInteger(filenameLength);
            data += filenameLengthBinary;
            
            // 文件名
            data += filename;
            
            // 数据长度（32位整数）
            const dataLength = bytes.length;
            const dataLengthBinary = encode32BitInteger(dataLength);
            data += dataLengthBinary;
            
            // 文件数据（每个字节作为一个字符）
            for (let i = 0; i < bytes.length; i++) {
                data += String.fromCharCode(bytes[i]);
            }
            
            return data;
        }
        
        // ============== 编码32位整数为2个Unicode字符 ==============
        function encode32BitInteger(value) {
            // 将32位整数编码为2个Unicode字符（21位×2=42位 > 32位）
            const high = (value >>> 21) & 0x7FF; // 高11位
            const low = value & 0x1FFFFF; // 低21位
            
            // 转换为两个Unicode字符
            return String.fromCodePoint(low) + String.fromCodePoint(high);
        }
        
        // ============== 解码2个Unicode字符为32位整数 ==============
        function decode32BitInteger(str) {
            if (str.length < 2) return 0;
            
            const low = str.codePointAt(0);
            const high = str.codePointAt(1);
            
            return (high << 21) | low;
        }
        
        // ============== 创建二进制图像 ==============
        function createBinaryImage(binaryArray) {
            const ctx = encodedCanvas.getContext('2d');
            const imageData = ctx.createImageData(currentWidth, currentHeight);
            const data = imageData.data;
            
            // 用白色填充整个画布
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255;     // R
                data[i+1] = 255;   // G
                data[i+2] = 255;   // B
                data[i+3] = 255;   // A
            }
            
            // 根据二进制数组设置像素颜色
            for (let i = 0; i < binaryArray.length && i < currentWidth * currentHeight; i++) {
                const bit = binaryArray[i];
                const pixelIndex = i * 4;
                
                if (bit === 1) {
                    data[pixelIndex] = 0;     // R
                    data[pixelIndex+1] = 0;   // G
                    data[pixelIndex+2] = 0;   // B
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // ============== 显示编码后的图像 ==============
        function displayEncodedImage() {
            // 隐藏占位符，显示canvas
            imageOutput.style.display = 'none';
            encodedCanvas.style.display = 'block';
        }
        
        // ============== 更新图像信息 ==============
        function updateImageInfo() {
            imageDimensions.textContent = `图像尺寸: ${currentWidth}×${currentHeight} 像素`;
            
            // 估计文件大小（PNG格式）
            const estimatedSizeKB = Math.round((currentWidth * currentHeight * 0.1) / 1024);
            imageSize.textContent = `文件大小: ~${estimatedSizeKB} KB`;
        }
        
        // ============== 下载图像 ==============
        function downloadImage() {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            
            link.download = `encoded-${currentFile.name.replace(/\.[^/.]+$/, "")}-${timestamp}.png`;
            link.href = encodedCanvas.toDataURL('image/png');
            link.click();
            showNotification('图像下载成功！', 'success');
        }
        
        // ============== 预览编码图像 ==============
        function previewEncodedImage(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // 设置canvas尺寸
                    decodedCanvas.width = img.width;
                    decodedCanvas.height = img.height;
                    const ctx = decodedCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // 显示图像
                    decodedImagePlaceholder.style.display = 'none';
                    decodedCanvas.style.display = 'block';
                    
                    // 更新检测到的图像尺寸
                    detectedImageSize.textContent = `${img.width}×${img.height} 像素`;
                };
                
                img.onerror = function() {
                    showNotification('无法加载图像文件', 'error');
                };
                
                img.src = e.target.result;
            };
            
            reader.onerror = function() {
                showNotification('无法读取文件', 'error');
            };
            
            reader.readAsDataURL(file);
        }
        
        // ============== 解码图像为文件 ==============
        function decodeImageToFile() {
            const file = imageInput.files[0];
            if (!file) {
                showNotification('请先选择图像文件', 'error');
                return;
            }
            
            showLoading(true);
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    try {
                        // 创建临时canvas
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        // 绘制图像
                        tempCtx.drawImage(img, 0, 0);
                        
                        // 获取像素数据
                        const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
                        const data = imageData.data;
                        
                        // 提取二进制字符串
                        const binaryArray = extractBinaryFromImage(data, img.width, img.height);
                        
                        // 将二进制数组转换为文本
                        const text = decodeBinaryToUnicode(binaryArray);
                        
                        // 解析文件数据
                        const fileInfo = parseFileData(text);
                        
                        if (!fileInfo) {
                            throw new Error('无法识别文件数据格式');
                        }
                        
                        // 保存解码信息
                        decodedFileInfo = fileInfo;
                        
                        // 显示解码信息
                        detectedFileName.textContent = fileInfo.filename;
                        detectedFileSize.textContent = formatFileSize(fileInfo.data.length);
                        detectedHeader.textContent = HEADER_MARKER;
                        decodeInfo.style.display = 'block';
                        
                        // 显示解码字节预览
                        decodedBytesContainer.style.display = 'block';
                        decodedBytesLength.textContent = `${fileInfo.data.length} 字节`;
                        showBytesPreviewForDecoded(fileInfo.data);
                        
                        // 启用下载文件按钮
                        downloadFileBtn.disabled = false;
                        
                        showNotification(`解码成功！检测到文件: ${fileInfo.filename}`, 'success');
                    } catch (error) {
                        console.error('解码错误:', error);
                        showNotification('解码过程中发生错误: ' + error.message, 'error');
                    } finally {
                        showLoading(false);
                    }
                };
                
                img.onerror = function() {
                    showNotification('无法加载图像文件', 'error');
                    showLoading(false);
                };
                
                img.src = e.target.result;
            };
            
            reader.onerror = function() {
                showNotification('无法读取文件', 'error');
                showLoading(false);
            };
            
            reader.readAsDataURL(file);
        }
        
        // ============== 显示解码字节预览 ==============
        function showBytesPreviewForDecoded(bytes) {
            const previewCount = Math.min(bytes.length, 1000);
            let previewText = '';
            for (let i = 0; i < previewCount; i++) {
                const byte = bytes[i];
                previewText += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
                if ((i + 1) % 16 === 0) previewText += '\n';
            }
            decodedBytesPreview.textContent = previewText;
        }
        
        // ============== 从图像数据提取二进制数组 ==============
        function extractBinaryFromImage(data, width, height) {
            const binaryArray = [];
            const totalPixels = width * height;
            
            for (let i = 0; i < totalPixels && i * 4 < data.length; i++) {
                const pixelIndex = i * 4;
                const r = data[pixelIndex];
                const g = data[pixelIndex + 1];
                const b = data[pixelIndex + 2];
                
                // 阈值判断（黑白图像）
                const isBlack = (r < 128 && g < 128 && b < 128);
                binaryArray.push(isBlack ? 1 : 0);
            }
            
            return binaryArray;
        }
        
        // ============== 解析文件数据 ==============
        function parseFileData(text) {
            // 检查头部标识
            if (!text.startsWith(HEADER_MARKER)) {
                return null;
            }
            
            let index = HEADER_MARKER.length;
            
            // 读取文件名长度
            if (index + 2 > text.length) return null;
            const filenameLengthStr = text.substring(index, index + 2);
            const filenameLength = decode32BitInteger(filenameLengthStr);
            index += 2;
            
            // 读取文件名
            if (index + filenameLength > text.length) return null;
            const filename = text.substring(index, index + filenameLength);
            index += filenameLength;
            
            // 读取数据长度
            if (index + 2 > text.length) return null;
            const dataLengthStr = text.substring(index, index + 2);
            const dataLength = decode32BitInteger(dataLengthStr);
            index += 2;
            
            // 读取文件数据
            if (index + dataLength > text.length) return null;
            
            // 将字符转换回字节
            const bytes = new Uint8Array(dataLength);
            for (let i = 0; i < dataLength; i++) {
                bytes[i] = text.charCodeAt(index + i);
            }
            
            return {
                filename: filename,
                data: bytes,
                size: dataLength
            };
        }
        
        // ============== 下载解码文件 ==============
        function downloadDecodedFile() {
            if (!decodedFileInfo) {
                showNotification('没有可下载的文件', 'error');
                return;
            }
            
            try {
                const blob = new Blob([decodedFileInfo.data]);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                a.href = url;
                a.download = decodedFileInfo.filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification(`文件下载成功：${decodedFileInfo.filename}`, 'success');
            } catch (error) {
                showNotification(`下载失败：${error.message}`, 'error');
            }
        }
        
        // ============== 显示/隐藏加载指示器 ==============
        function showLoading(show) {
            if (show) {
                loadingIndicator.classList.add('active');
                encodeBtn.disabled = true;
                decodeBtn.disabled = true;
            } else {
                loadingIndicator.classList.remove('active');
                encodeBtn.disabled = !currentFile;
                decodeBtn.disabled = !imageInput.files.length;
            }
        }
        
        // ============== 显示通知 ==============
        function showNotification(message, type = 'info') {
            notificationMessage.textContent = message;
            notification.className = 'notification';
            notification.classList.add(type);
            
            let iconClass = 'fas fa-info-circle';
            if (type === 'success') iconClass = 'fas fa-check-circle';
            else if (type === 'error') iconClass = 'fas fa-exclamation-circle';
            else if (type === 'warning') iconClass = 'fas fa-exclamation-triangle';
            
            notificationIcon.className = iconClass;
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // ============== 辅助函数 ==============
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function getFileExtension(filename) {
            const ext = filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2);
            return ext ? ext.toUpperCase() + ' 文件' : '未知类型';
        }
        
        // ============== 键盘快捷键 ==============
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ctrl+E 编码
                if (e.ctrlKey && e.key === 'e') {
                    if (!encodeBtn.disabled) {
                        encodeFileToImage();
                        e.preventDefault();
                    }
                }
                
                // Ctrl+D 解码
                if (e.ctrlKey && e.key === 'd') {
                    if (!decodeBtn.disabled) {
                        decodeImageToFile();
                        e.preventDefault();
                    }
                }
            });
        }
        
        // ============== 控制台信息 ==============
        console.log('%c🔐 文件↔图像转换器（黑白Unicode编码）v1.0 %c已加载完成！', 
            'color: #6c63ff; font-size: 16px; font-weight: bold;', 
            'color: #4caf50; font-size: 14px;');
        console.log('%c📋 功能特性:', 'color: #2196f3; font-weight: bold;');
        console.log('- 支持任意文件类型编码为黑白图像');
        console.log('- Unicode编码，每个字符21位二进制');
        console.log('- 每个像素1位（0=白色，1=黑色）');
        console.log('- 自动保存文件名和文件内容');
        console.log('- 直接使用原始二进制数据，无Base64转换');
        console.log('%c⌨️ 快捷键:', 'color: #ff9800; font-weight: bold;');
        console.log('Ctrl+E: 编码文件');
        console.log('Ctrl+D: 解码图像');
    </script>
</body>
</html>
