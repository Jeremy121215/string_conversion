<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文件↔图像转换器（黑白/彩色编码版）</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00dbde, #fc00ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #a0a0c0;
            margin-bottom: 5px;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .stat-box {
            background: rgba(30, 30, 60, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 100, 200, 0.2);
        }
        
        .card-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3a3a7a;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-title i {
            color: #6c63ff;
        }
        
        .file-upload-area {
            border: 3px dashed #3a3a7a;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            background: rgba(30, 30, 60, 0.5);
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-upload-area:hover {
            border-color: #6c63ff;
            background: rgba(60, 60, 100, 0.7);
        }
        
        .upload-icon {
            font-size: 3.5rem;
            color: #6c63ff;
            margin-bottom: 15px;
        }
        
        .file-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.95rem;
        }
        
        .file-info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .file-info-row:last-child {
            border-bottom: none;
        }
        
        .file-info-label {
            color: #a0a0c0;
        }
        
        .file-info-value {
            color: #ffffff;
            font-weight: 600;
        }
        
        .dimension-controls {
            background: rgba(30, 30, 60, 0.7);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .dimension-controls label {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            min-width: 150px;
        }
        
        .dimension-controls span {
            font-size: 0.9rem;
            color: #a0a0c0;
        }
        
        .dimension-controls input {
            padding: 8px 12px;
            background: rgba(10, 10, 20, 0.8);
            border: 1px solid #3a3a7a;
            border-radius: 4px;
            color: #e0e0e0;
        }
        
        .dimension-controls input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .dimension-controls button {
            padding: 8px 16px;
            background: rgba(60, 60, 100, 0.8);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .dimension-controls button:hover {
            background: rgba(80, 80, 140, 0.8);
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(90deg, #6c63ff, #3a3a7a);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(90deg, #5a52e0, #2a2a5a);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(108, 99, 255, 0.3);
        }
        
        .btn-secondary {
            background: rgba(60, 60, 100, 0.8);
            color: white;
        }
        
        .btn-secondary:hover {
            background: rgba(80, 80, 140, 0.8);
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: linear-gradient(90deg, #4caf50, #2e7d32);
            color: white;
        }
        
        .btn-success:hover:not(:disabled) {
            background: linear-gradient(90deg, #3d8b40, #1b5e20);
            transform: translateY(-2px);
        }
        
        .btn-warning {
            background: linear-gradient(90deg, #ff9800, #f57c00);
            color: white;
        }
        
        .btn-warning:hover {
            background: linear-gradient(90deg, #f57c00, #e65100);
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .canvas-wrapper {
            width: 100%;
            background: rgba(10, 10, 20, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }
        
        canvas {
            max-width: 100%;
            max-height: 400px;
            border: 1px solid #3a3a7a;
            border-radius: 4px;
            background-color: white;
        }
        
        .image-placeholder {
            width: 100%;
            height: 300px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #8888aa;
            border: 2px dashed #3a3a7a;
            border-radius: 8px;
        }
        
        .image-placeholder i {
            font-size: 3rem;
            margin-bottom: 15px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-label {
            display: block;
            padding: 12px 24px;
            background: rgba(60, 60, 100, 0.8);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .file-input-label:hover {
            background: rgba(80, 80, 140, 0.8);
        }
        
        .result-box {
            margin-top: 20px;
            padding: 15px;
            background: rgba(10, 10, 20, 0.8);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            border: 1px solid #3a3a7a;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #6c63ff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .info-box {
            grid-column: 1 / -1;
            margin-top: 20px;
            background: rgba(30, 30, 60, 0.7);
            border-left: 4px solid #6c63ff;
        }
        
        .info-box h3 {
            margin-bottom: 10px;
            color: #a0a0ff;
        }
        
        .info-box ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }
        
        .info-box li {
            margin-bottom: 5px;
        }
        
        .image-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #a0a0c0;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .size-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }
        
        .unicode-badge {
            background: rgba(33, 150, 243, 0.2);
            color: #2196f3;
        }
        
        .bw-badge {
            background: rgba(158, 158, 158, 0.2);
            color: #9e9e9e;
        }
        
        .color-badge {
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid rgba(100, 100, 200, 0.2);
            color: #8888aa;
            font-size: 0.9rem;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background: rgba(40, 40, 80, 0.95);
            border-radius: 8px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 10px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.4s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification.success {
            border-left: 4px solid #4caf50;
        }
        
        .notification.error {
            border-left: 4px solid #ff5252;
        }
        
        .notification.info {
            border-left: 4px solid #2196f3;
        }
        
        .notification.warning {
            border-left: 4px solid #ff9800;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(60, 60, 100, 0.8);
            border-radius: 13px;
            margin-right: 10px;
            transition: background 0.3s;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 11px;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        
        .toggle-checkbox:checked + .toggle-switch {
            background: #6c63ff;
        }
        
        .toggle-checkbox:checked + .toggle-switch::after {
            transform: translateX(24px);
        }
        
        .toggle-checkbox {
            display: none;
        }
        
        .encoding-info {
            background: rgba(30, 30, 60, 0.7);
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #a0a0c0;
            border-left: 3px solid #6c63ff;
            margin-bottom: 15px;
        }
        
        .bits-info {
            background: rgba(30, 30, 60, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.85rem;
        }
        
        .bits-info span {
            font-family: monospace;
            color: #6c63ff;
            font-weight: bold;
        }
        
        .char-count {
            text-align: right;
            margin-bottom: 15px;
            font-size: 0.9rem;
            color: #a0a0c0;
        }
        
        .char-count.warning {
            color: #ff9800;
        }
        
        .char-count.error {
            color: #ff5252;
        }
        
        .preview-text {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 0.9rem;
            max-height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            display: none;
        }
        
        .preview-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: #b0d4e0;
        }
        
        .header-marker {
            background: rgba(108, 99, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8rem;
        }
        
        /* 编码模式选择 */
        .encoding-mode-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .encoding-mode {
            flex: 1;
            padding: 12px;
            background: rgba(30, 30, 60, 0.7);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .encoding-mode:hover {
            background: rgba(40, 40, 80, 0.8);
        }
        
        .encoding-mode.active {
            border-color: #6c63ff;
            background: rgba(108, 99, 255, 0.1);
        }
        
        .encoding-mode-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .encoding-mode-desc {
            font-size: 0.85rem;
            color: #a0a0c0;
        }
        
        /* 内存信息 */
        .memory-info {
            background: rgba(30, 30, 60, 0.7);
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9rem;
            border-left: 3px solid #4caf50;
        }
        
        .memory-info.warning {
            border-left: 3px solid #ff9800;
        }
        
        .memory-info.danger {
            border-left: 3px solid #ff5252;
        }
        
        .memory-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .memory-info-row:last-child {
            margin-bottom: 0;
        }
        
        /* 颜色映射表 */
        .color-map {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin-top: 10px;
            margin-bottom: 15px;
        }
        
        .color-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.7rem;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 2px;
        }
        
        @media (max-width: 768px) {
            .stats {
                flex-direction: column;
                align-items: center;
            }
            
            .dimension-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .encoding-mode-selector {
                flex-direction: column;
            }
            
            .color-map {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-file-image"></i> 文件↔图像转换器（黑白/彩色编码版）</h1>
            <p class="subtitle">将任意文件编码为黑白或彩色图像，支持Unicode编码</p>
            <div class="stats">
                <div class="stat-box">黑白模式: 21位/字符</div>
                <div class="stat-box">彩色模式: 6位十六进制/字符</div>
                <div class="stat-box">支持文件: 任意类型</div>
            </div>
        </header>
        
        <div class="main-content">
            <!-- 编码部分 -->
            <div class="card">
                <h2 class="card-title"><i class="fas fa-lock"></i> 编码文件到图像</h2>
                
                <!-- 编码模式选择 -->
                <div class="encoding-mode-selector">
                    <div class="encoding-mode" id="bwMode" data-mode="bw">
                        <div class="encoding-mode-title">黑白模式</div>
                        <div class="encoding-mode-desc">每个字符21位，1位/像素</div>
                    </div>
                    <div class="encoding-mode" id="colorMode" data-mode="color">
                        <div class="encoding-mode-title">彩色模式</div>
                        <div class="encoding-mode-desc">6位十六进制/字符，2像素/字符</div>
                    </div>
                </div>
                
                <!-- 颜色映射表（彩色模式显示） -->
                <div id="colorMapContainer" class="color-map" style="display: none;">
                    <!-- 颜色映射将通过JS动态生成 -->
                </div>
                
                <!-- 编码信息 -->
                <div class="encoding-info" id="encodingInfo">
                    <i class="fas fa-info-circle"></i> 
                    <span id="encodingDescription">黑白编码模式：每个字符使用21位二进制编码，每个像素1位（0=白色，1=黑色）</span>
                </div>
                
                <!-- 文件上传区域 -->
                <div id="fileUploadArea" class="file-upload-area">
                    <div class="upload-icon">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <h3>点击或拖放文件到此区域</h3>
                    <p>支持任意文件类型：图片、文档、压缩包、视频等</p>
                    <input type="file" id="fileInput" style="display: none;">
                </div>
                
                <!-- 文件信息 -->
                <div id="fileInfo" class="file-info" style="display: none;">
                    <div class="file-info-row">
                        <span class="file-info-label">文件名：</span>
                        <span id="fileName" class="file-info-value">未选择文件</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">文件大小：</span>
                        <span id="fileSize" class="file-info-value">0 KB</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">文件类型：</span>
                        <span id="fileType" class="file-info-value">未知</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">数据头部：</span>
                        <span id="fileHeader" class="file-info-value">FIMG|</span>
                    </div>
                </div>
                
                <!-- 内存信息 -->
                <div id="memoryInfo" class="memory-info">
                    <div class="memory-info-row">
                        <span><i class="fas fa-memory"></i> 最大可用内存：</span>
                        <span id="maxMemory">约 1 GB</span>
                    </div>
                    <div class="memory-info-row">
                        <span><i class="fas fa-file"></i> 文件内存：</span>
                        <span id="fileMemory">0 MB</span>
                    </div>
                    <div class="memory-info-row">
                        <span><i class="fas fa-image"></i> 图像内存：</span>
                        <span id="imageMemory">0 MB</span>
                    </div>
                    <div class="memory-info-row">
                        <span><i class="fas fa-tachometer-alt"></i> 总内存使用：</span>
                        <span id="totalMemory">0 MB</span>
                    </div>
                </div>
                
                <!-- 自动尺寸切换 -->
                <div class="toggle-container">
                    <label class="toggle-label">
                        <input type="checkbox" id="autoSizeToggle" class="toggle-checkbox" checked>
                        <span class="toggle-switch"></span>
                        <span>自动调整图像尺寸</span>
                    </label>
                    <span id="toggleStatus" class="size-badge bw-badge">已启用</span>
                </div>
                
                <!-- 图像尺寸控制 -->
                <div id="dimensionControls" class="dimension-controls" style="display: none;">
                    <label>
                        <span>图像宽度:</span>
                        <input type="number" id="imageWidth" min="100" max="10000" value="980">
                    </label>
                    <label>
                        <span>图像高度:</span>
                        <input type="number" id="imageHeight" min="142" max="10000" value="1400">
                    </label>
                    <label>
                        <span>宽高比:</span>
                        <input type="text" id="aspectRatio" value="1:1.43" disabled>
                    </label>
                    <button id="calculateDimensionsBtn">
                        <i class="fas fa-calculator"></i> 计算尺寸
                    </button>
                </div>
                
                <!-- 字符计数和位信息 -->
                <div class="char-count" id="charCount">总字符数: 0 (0像素)</div>
                <div id="bitsInfo" class="bits-info" style="display: none;">
                    <i class="fas fa-microchip"></i> 总位数: <span id="totalBits">0</span> 位 | 像素需求: <span id="pixelsNeeded">0</span> 像素
                </div>
                
                <!-- 按钮组 -->
                <div class="button-group">
                    <button id="encodeBtn" class="btn btn-primary" disabled>
                        <i class="fas fa-cogs"></i> 编码为图像
                    </button>
                    <button id="clearInputBtn" class="btn btn-secondary">
                        <i class="fas fa-trash-alt"></i> 清空输入
                    </button>
                </div>
                
                <!-- 图像输出 -->
                <div class="canvas-wrapper">
                    <div id="imageOutput" class="image-placeholder">
                        <i class="fas fa-image"></i>
                        <p>编码后的图像将在这里显示</p>
                    </div>
                    <canvas id="encodedCanvas"></canvas>
                </div>
                
                <div class="image-info">
                    <div id="imageDimensions">图像尺寸: 未生成</div>
                    <div id="imageSize">文件大小: 未生成</div>
                    <div id="encodingModeIndicator">编码模式: 黑白</div>
                </div>
                
                <button id="downloadBtn" class="btn btn-success" disabled style="margin-top: 10px;">
                    <i class="fas fa-download"></i> 下载图像
                </button>
            </div>
            
            <!-- 解码部分 -->
            <div class="card">
                <h2 class="card-title"><i class="fas fa-unlock"></i> 从图像解码文件</h2>
                
                <!-- 解码模式选择 -->
                <div class="encoding-mode-selector">
                    <div class="encoding-mode active" id="decodeBwMode" data-mode="bw">
                        <div class="encoding-mode-title">黑白解码</div>
                        <div class="encoding-mode-desc">从黑白图像解码</div>
                    </div>
                    <div class="encoding-mode" id="decodeColorMode" data-mode="color">
                        <div class="encoding-mode-title">彩色解码</div>
                        <div class="encoding-mode-desc">从彩色图像解码</div>
                    </div>
                </div>
                
                <div class="encoding-info">
                    <i class="fas fa-info-circle"></i> 
                    请上传之前编码生成的图像。系统会自动识别编码模式并提取文件。
                </div>
                
                <!-- 图像上传 -->
                <div class="file-input-wrapper" style="margin-bottom: 20px;">
                    <div class="file-input-label">
                        <i class="fas fa-upload"></i> 选择编码图像（PNG格式）
                    </div>
                    <input type="file" id="imageInput" accept="image/png">
                </div>
                
                <!-- 解码信息 -->
                <div id="decodeInfo" class="file-info" style="display: none;">
                    <div class="file-info-row">
                        <span class="file-info-label">检测到文件：</span>
                        <span id="detectedFileName" class="file-info-value">未识别</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">文件大小：</span>
                        <span id="detectedFileSize" class="file-info-value">0 KB</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">头部标识：</span>
                        <span id="detectedHeader" class="file-info-value">未识别</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">图像尺寸：</span>
                        <span id="detectedImageSize" class="file-info-value">0×0 像素</span>
                    </div>
                    <div class="file-info-row">
                        <span class="file-info-label">编码模式：</span>
                        <span id="detectedEncodingMode" class="file-info-value">未识别</span>
                    </div>
                </div>
                
                <!-- 解码图像预览 -->
                <div class="canvas-wrapper">
                    <div id="decodedImagePlaceholder" class="image-placeholder">
                        <i class="fas fa-image"></i>
                        <p>上传的图像将在这里预览</p>
                    </div>
                    <canvas id="decodedCanvas"></canvas>
                </div>
                
                <!-- 按钮组 -->
                <div class="button-group">
                    <button id="decodeBtn" class="btn btn-primary" disabled>
                        <i class="fas fa-search"></i> 解码图像
                    </button>
                    <button id="clearOutputBtn" class="btn btn-secondary">
                        <i class="fas fa-trash-alt"></i> 清空
                    </button>
                </div>
                
                <!-- 字节预览 -->
                <div id="decodedBytesContainer" class="preview-text">
                    <div class="preview-header">
                        <span>解码字节预览（前1000字节）：</span>
                        <span id="decodedBytesLength">0 字节</span>
                    </div>
                    <div id="decodedBytesPreview"></div>
                </div>
                
                <!-- 下载按钮 -->
                <button id="downloadFileBtn" class="btn btn-success" disabled style="margin-top: 10px;">
                    <i class="fas fa-download"></i> 下载解码文件
                </button>
            </div>
            
            <!-- 算法说明 -->
            <div class="card info-box">
                <h3><i class="fas fa-calculator"></i> 编码算法说明</h3>
                <ul>
                    <li><strong>数据格式</strong>：
                        <ul>
                            <li>头部标识：<span class="header-marker">FIMG|</span> (固定5字符)</li>
                            <li>文件名长度：4字节（32位）整数</li>
                            <li>文件名：原文件名（Unicode编码）</li>
                            <li>文件数据长度：4字节（32位）整数</li>
                            <li>文件数据：原始二进制字节数据</li>
                        </ul>
                    </li>
                    <li><strong>黑白编码</strong>：
                        <ul>
                            <li>每个字符转换为21位二进制（Unicode编码）</li>
                            <li>每个二进制位对应一个像素（0=白色，1=黑色）</li>
                            <li>每个字符需要21个像素</li>
                        </ul>
                    </li>
                    <li><strong>彩色编码</strong>：
                        <ul>
                            <li>每个字符转换为6位十六进制（24位二进制）</li>
                            <li>每2位十六进制对应一个像素的RGB值</li>
                            <li>十六进制到RGB映射：0=0, 1=17, 2=34, ..., f=255</li>
                            <li>每个字符需要2个像素</li>
                            <li>例如：字符"0078fa" → 像素1(0,0,119), 像素2(136,255,170)</li>
                        </ul>
                    </li>
                    <li><strong>技术参数</strong>：
                        <ul>
                            <li>黑白模式：21位/字符，1像素/位</li>
                            <li>彩色模式：24位/字符，2像素/字符</li>
                            <li>支持最大Unicode码点：0x10FFFF</li>
                            <li>图像宽高比：接近A4比例（1:1.414）</li>
                            <li>直接使用原始二进制数据，无Base64转换</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
        
        <!-- 加载指示器 -->
        <div id="loadingIndicator" class="loading">
            <div class="spinner"></div>
            <p>正在处理中，请稍候...</p>
        </div>
        
        <footer>
            <p>文件↔图像转换器（黑白/彩色编码版） | 支持任意文件类型 | 黑白/彩色双模式 | 内存优化处理</p>
            <p>© 2023 文件图像转换工具 | 基于Unicode编码标准</p>
        </footer>
    </div>
    
    <!-- 通知 -->
    <div id="notification" class="notification">
        <i id="notificationIcon" class="fas fa-info-circle"></i>
        <span id="notificationMessage">这是一条通知</span>
    </div>

    <script>
        // ============== DOM元素 ==============
        const fileInput = document.getElementById('fileInput');
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const fileType = document.getElementById('fileType');
        const fileHeader = document.getElementById('fileHeader');
        
        const bytesPreviewContainer = document.getElementById('bytesPreviewContainer');
        const bytesPreview = document.getElementById('bytesPreview');
        const bytesPreviewLength = document.getElementById('bytesPreviewLength');
        
        const charCount = document.getElementById('charCount');
        const encodeBtn = document.getElementById('encodeBtn');
        const clearInputBtn = document.getElementById('clearInputBtn');
        const encodedCanvas = document.getElementById('encodedCanvas');
        const imageOutput = document.getElementById('imageOutput');
        const downloadBtn = document.getElementById('downloadBtn');
        const imageInput = document.getElementById('imageInput');
        const decodeBtn = document.getElementById('decodeBtn');
        const clearOutputBtn = document.getElementById('clearOutputBtn');
        const downloadFileBtn = document.getElementById('downloadFileBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const notification = document.getElementById('notification');
        const notificationIcon = document.getElementById('notificationIcon');
        const notificationMessage = document.getElementById('notificationMessage');
        
        const autoSizeToggle = document.getElementById('autoSizeToggle');
        const dimensionControls = document.getElementById('dimensionControls');
        const imageWidthInput = document.getElementById('imageWidth');
        const imageHeightInput = document.getElementById('imageHeight');
        const aspectRatioInput = document.getElementById('aspectRatio');
        const calculateDimensionsBtn = document.getElementById('calculateDimensionsBtn');
        const toggleStatus = document.getElementById('toggleStatus');
        const imageDimensions = document.getElementById('imageDimensions');
        const imageSize = document.getElementById('imageSize');
        const encodingModeIndicator = document.getElementById('encodingModeIndicator');
        
        const bitsInfo = document.getElementById('bitsInfo');
        const totalBits = document.getElementById('totalBits');
        const pixelsNeeded = document.getElementById('pixelsNeeded');
        
        const decodeInfo = document.getElementById('decodeInfo');
        const detectedFileName = document.getElementById('detectedFileName');
        const detectedFileSize = document.getElementById('detectedFileSize');
        const detectedHeader = document.getElementById('detectedHeader');
        const detectedImageSize = document.getElementById('detectedImageSize');
        const detectedEncodingMode = document.getElementById('detectedEncodingMode');
        
        const decodedImagePlaceholder = document.getElementById('decodedImagePlaceholder');
        const decodedCanvas = document.getElementById('decodedCanvas');
        const decodedBytesContainer = document.getElementById('decodedBytesContainer');
        const decodedBytesPreview = document.getElementById('decodedBytesPreview');
        const decodedBytesLength = document.getElementById('decodedBytesLength');
        
        // 编码模式相关元素
        const bwMode = document.getElementById('bwMode');
        const colorMode = document.getElementById('colorMode');
        const encodingInfo = document.getElementById('encodingInfo');
        const encodingDescription = document.getElementById('encodingDescription');
        const colorMapContainer = document.getElementById('colorMapContainer');
        
        // 解码模式相关元素
        const decodeBwMode = document.getElementById('decodeBwMode');
        const decodeColorMode = document.getElementById('decodeColorMode');
        
        // 内存信息元素
        const memoryInfo = document.getElementById('memoryInfo');
        const maxMemory = document.getElementById('maxMemory');
        const fileMemory = document.getElementById('fileMemory');
        const imageMemory = document.getElementById('imageMemory');
        const totalMemory = document.getElementById('totalMemory');
        
        // ============== 常量定义 ==============
        const HEADER_MARKER = 'FIMG|'; // 头部标识
        const BITS_PER_CHAR_BW = 21; // 黑白模式每个字符21位
        const BITS_PER_CHAR_COLOR = 24; // 彩色模式每个字符24位（6位十六进制）
        const MAX_UNICODE = 0x10FFFF; // Unicode最大码点
        const MIN_WIDTH = 100;
        const MIN_HEIGHT = 142;
        const MAX_WIDTH = 10000;
        const MAX_HEIGHT = 14140;
        const ASPECT_RATIO = 1.414; // A4比例
        
        // 十六进制到RGB的映射（增加容错版本）
        const HEX_TO_RGB = {
            '0': 0, '1': 17, '2': 34, '3': 51,
            '4': 68, '5': 85, '6': 102, '7': 119,
            '8': 136, '9': 153, 'a': 170, 'b': 187,
            'c': 204, 'd': 221, 'e': 238, 'f': 255
        };
        
        // 反向映射：RGB到HEX（带容错）
        const RGB_TO_HEX_TOLERANT = {};
        for (let i = 0; i <= 255; i++) {
            // 找到最接近的标准值
            let minDiff = Infinity;
            let closestHex = '0';
            
            for (const [hex, rgb] of Object.entries(HEX_TO_RGB)) {
                const diff = Math.abs(i - rgb);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestHex = hex;
                }
            }
            RGB_TO_HEX_TOLERANT[i] = closestHex;
        }
        
        const RGB_TO_HEX = {};
        for (const [hex, rgb] of Object.entries(HEX_TO_RGB)) {
            RGB_TO_HEX[rgb] = hex;
        }
        
        // 内存限制（假设最大可用内存为1GB）
        const MAX_MEMORY_BYTES = 1 * 1024 * 1024 * 1024; // 1GB
        
        // ============== 状态变量 ==============
        let currentFile = null;
        let fileData = null;
        let autoSizeEnabled = true;
        let currentWidth = 980;
        let currentHeight = 1400;
        let decodedFileInfo = null;
        let encodingMode = 'bw'; // 'bw' 或 'color'
        let decodeMode = 'bw'; // 解码模式
        
        // ============== 初始化 ==============
        document.addEventListener('DOMContentLoaded', function() {
            initializePage();
        });
        
        function initializePage() {
            setupEventListeners();
            updateAspectRatio();
            updateColorMap();
            updateMaxMemoryInfo();
            
            // 初始化canvas样式
            encodedCanvas.style.display = 'none';
            decodedCanvas.style.display = 'none';
            
            // 显示欢迎信息
            setTimeout(() => {
                showNotification('文件↔图像转换器已加载！支持黑白和彩色两种编码模式。', 'info');
            }, 1000);
        }
        
        // ============== 更新最大内存信息 ==============
        function updateMaxMemoryInfo() {
            const maxMemoryMB = (MAX_MEMORY_BYTES / (1024 * 1024)).toFixed(0);
            maxMemory.textContent = `约 ${maxMemoryMB} MB`;
        }
        
        // ============== 更新颜色映射表 ==============
        function updateColorMap() {
            colorMapContainer.innerHTML = '';
            
            for (const [hex, rgb] of Object.entries(HEX_TO_RGB)) {
                const colorItem = document.createElement('div');
                colorItem.className = 'color-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = `rgb(${rgb}, ${rgb}, ${rgb})`;
                
                const hexLabel = document.createElement('div');
                hexLabel.textContent = hex;
                
                const rgbLabel = document.createElement('div');
                rgbLabel.textContent = rgb;
                rgbLabel.style.fontSize = '0.6rem';
                rgbLabel.style.color = '#888';
                
                colorItem.appendChild(colorBox);
                colorItem.appendChild(hexLabel);
                colorItem.appendChild(rgbLabel);
                
                colorMapContainer.appendChild(colorItem);
            }
        }
        
        // ============== 事件监听器设置 ==============
        function setupEventListeners() {
            // 文件上传区域点击
            fileUploadArea.addEventListener('click', () => fileInput.click());
            
            // 文件拖放支持
            fileUploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileUploadArea.style.borderColor = '#6c63ff';
                fileUploadArea.style.background = 'rgba(60, 60, 100, 0.7)';
            });
            
            fileUploadArea.addEventListener('dragleave', () => {
                fileUploadArea.style.borderColor = '#3a3a7a';
                fileUploadArea.style.background = 'rgba(30, 30, 60, 0.5)';
            });
            
            fileUploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                fileUploadArea.style.borderColor = '#3a3a7a';
                fileUploadArea.style.background = 'rgba(30, 30, 60, 0.5)';
                
                if (e.dataTransfer.files.length > 0) {
                    handleFileSelect(e.dataTransfer.files[0]);
                }
            });
            
            // 文件选择
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileSelect(e.target.files[0]);
                }
            });
            
            // 图像上传区域
            imageInput.addEventListener('change', function() {
                decodeBtn.disabled = !this.files.length;
                if (this.files.length > 0) {
                    previewEncodedImage(this.files[0]);
                }
            });
            
            // 编码模式选择
            bwMode.addEventListener('click', () => {
                setEncodingMode('bw');
            });
            
            colorMode.addEventListener('click', () => {
                setEncodingMode('color');
            });
            
            // 解码模式选择
            decodeBwMode.addEventListener('click', () => {
                setDecodeMode('bw');
            });
            
            decodeColorMode.addEventListener('click', () => {
                setDecodeMode('color');
            });
            
            // 自动尺寸切换
            autoSizeToggle.addEventListener('change', function() {
                autoSizeEnabled = this.checked;
                dimensionControls.style.display = autoSizeEnabled ? 'none' : 'flex';
                toggleStatus.textContent = autoSizeEnabled ? '已启用' : '已禁用';
                updateFileInfo();
            });
            
            // 手动尺寸输入
            imageWidthInput.addEventListener('input', function() {
                if (!autoSizeEnabled) {
                    const width = parseInt(this.value) || MIN_WIDTH;
                    const height = Math.round(width * ASPECT_RATIO);
                    imageHeightInput.value = height;
                    updateAspectRatio();
                    updateFileInfo();
                }
            });
            
            imageHeightInput.addEventListener('input', function() {
                if (!autoSizeEnabled) {
                    const height = parseInt(this.value) || MIN_HEIGHT;
                    const width = Math.round(height / ASPECT_RATIO);
                    imageWidthInput.value = width;
                    updateAspectRatio();
                    updateFileInfo();
                }
            });
            
            // 计算尺寸按钮
            calculateDimensionsBtn.addEventListener('click', function() {
                if (!autoSizeEnabled) {
                    const width = parseInt(imageWidthInput.value) || MIN_WIDTH;
                    const height = parseInt(imageHeightInput.value) || MIN_HEIGHT;
                    currentWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, width));
                    currentHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, height));
                    imageWidthInput.value = currentWidth;
                    imageHeightInput.value = currentHeight;
                    updateAspectRatio();
                    updateFileInfo();
                    showNotification(`图像尺寸已设置为 ${currentWidth}×${currentHeight} 像素`, 'info');
                }
            });
            
            // 编码按钮
            encodeBtn.addEventListener('click', encodeFileToImage);
            
            // 清空输入按钮
            clearInputBtn.addEventListener('click', () => {
                clearEncoder();
                showNotification('输入已清空', 'info');
            });
            
            // 下载按钮
            downloadBtn.addEventListener('click', downloadImage);
            
            // 解码按钮
            decodeBtn.addEventListener('click', decodeImageToFile);
            
            // 清空输出按钮
            clearOutputBtn.addEventListener('click', () => {
                clearDecoder();
                showNotification('输出已清空', 'info');
            });
            
            // 下载文件按钮
            downloadFileBtn.addEventListener('click', downloadDecodedFile);
            
            // 设置键盘快捷键
            setupKeyboardShortcuts();
        }
        
        // ============== 设置编码模式 ==============
        function setEncodingMode(mode) {
            encodingMode = mode;
            
            // 更新UI
            bwMode.classList.remove('active');
            colorMode.classList.remove('active');
            
            if (mode === 'bw') {
                bwMode.classList.add('active');
                encodingDescription.textContent = '黑白编码模式：每个字符使用21位二进制编码，每个像素1位（0=白色，1=黑色）';
                colorMapContainer.style.display = 'none';
                toggleStatus.className = 'size-badge bw-badge';
                toggleStatus.textContent = autoSizeEnabled ? '已启用' : '已禁用';
            } else {
                colorMode.classList.add('active');
                encodingDescription.textContent = '彩色编码模式：每个字符转换为6位十六进制，每2位十六进制对应一个像素的RGB值';
                colorMapContainer.style.display = 'grid';
                toggleStatus.className = 'size-badge color-badge';
                toggleStatus.textContent = autoSizeEnabled ? '已启用' : '已禁用';
            }
            
            updateFileInfo();
            showNotification(`已切换到${mode === 'bw' ? '黑白' : '彩色'}编码模式`, 'info');
        }
        
        // ============== 设置解码模式 ==============
        function setDecodeMode(mode) {
            decodeMode = mode;
            
            // 更新UI
            decodeBwMode.classList.remove('active');
            decodeColorMode.classList.remove('active');
            
            if (mode === 'bw') {
                decodeBwMode.classList.add('active');
            } else {
                decodeColorMode.classList.add('active');
            }
            
            showNotification(`已切换到${mode === 'bw' ? '黑白' : '彩色'}解码模式`, 'info');
        }
        
        // ============== 清空编码器 ==============
        function clearEncoder() {
            currentFile = null;
            fileData = null;
            fileInput.value = '';
            fileInfo.style.display = 'none';
            imageOutput.style.display = 'flex';
            encodedCanvas.style.display = 'none';
            encodeBtn.disabled = true;
            downloadBtn.disabled = true;
            bitsInfo.style.display = 'none';
            charCount.textContent = '总字符数: 0 (0像素)';
            imageDimensions.textContent = '图像尺寸: 未生成';
            imageSize.textContent = '文件大小: 未生成';
            encodingModeIndicator.textContent = `编码模式: ${encodingMode === 'bw' ? '黑白' : '彩色'}`;
            
            // 重置内存信息
            updateMemoryInfo(0, 0, 0);
        }
        
        // ============== 清空解码器 ==============
        function clearDecoder() {
            decodedFileInfo = null;
            imageInput.value = '';
            decodeInfo.style.display = 'none';
            decodedBytesContainer.style.display = 'none';
            decodedImagePlaceholder.style.display = 'flex';
            decodedCanvas.style.display = 'none';
            decodeBtn.disabled = true;
            downloadFileBtn.disabled = true;
        }
        
        // ============== 文件选择处理 ==============
        function handleFileSelect(file) {
            currentFile = file;
            
            // 显示文件信息
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileType.textContent = getFileExtension(file.name);
            fileHeader.textContent = HEADER_MARKER;
            
            // 显示文件信息面板
            fileInfo.style.display = 'block';
            
            // 读取文件数据
            const reader = new FileReader();
            reader.onload = function(e) {
                fileData = e.target.result;
                
                // 更新文件信息
                updateFileInfo();
                
                // 启用编码按钮
                encodeBtn.disabled = false;
            };
            
            reader.onerror = function() {
                showNotification('文件读取失败', 'error');
            };
            
            reader.readAsArrayBuffer(file);
            
            showNotification(`已选择文件：${file.name}`, 'success');
        }
        
        // ============== 更新文件信息 ==============
        function updateFileInfo() {
            if (!currentFile || !fileData) return;
            
            const bytes = new Uint8Array(fileData);
            const totalChars = calculateTotalChars(currentFile.name, bytes);
            
            // 根据编码模式计算像素需求
            let pixelsRequired = 0;
            let bitsPerChar = 0;
            
            if (encodingMode === 'bw') {
                bitsPerChar = BITS_PER_CHAR_BW;
                pixelsRequired = totalChars * bitsPerChar; // 黑白模式：每个字符需要21个像素
            } else {
                bitsPerChar = BITS_PER_CHAR_COLOR;
                pixelsRequired = totalChars * 2; // 彩色模式：每个字符需要2个像素
            }
            
            // 更新字符计数和位信息
            totalBits.textContent = (totalChars * bitsPerChar).toLocaleString();
            pixelsNeeded.textContent = pixelsRequired.toLocaleString();
            bitsInfo.style.display = 'block';
            
            if (autoSizeEnabled) {
                // 计算最佳图像尺寸
                const calculated = calculateOptimalDimensions(pixelsRequired);
                currentWidth = calculated.width;
                currentHeight = calculated.height;
                
                charCount.textContent = `总字符数: ${totalChars.toLocaleString()} (${pixelsRequired.toLocaleString()}像素)`;
                charCount.textContent += ` | 图像尺寸: ${currentWidth}×${currentHeight}`;
                charCount.classList.remove('warning', 'error');
            } else {
                currentWidth = parseInt(imageWidthInput.value) || MIN_WIDTH;
                currentHeight = parseInt(imageHeightInput.value) || MIN_HEIGHT;
                const maxPixels = currentWidth * currentHeight;
                
                charCount.textContent = `总字符数: ${totalChars.toLocaleString()} (${pixelsRequired.toLocaleString()}像素)`;
                
                if (pixelsRequired > maxPixels) {
                    charCount.classList.add('error');
                    const neededHeight = Math.ceil(pixelsRequired / currentWidth);
                    charCount.textContent += ` (错误: 需要至少 ${neededHeight} 像素高度)`;
                } else {
                    charCount.classList.remove('warning', 'error');
                }
            }
            
            // 更新内存信息
            updateMemoryInfo(bytes.length, currentWidth, currentHeight);
            
            // 更新编码模式指示器
            encodingModeIndicator.textContent = `编码模式: ${encodingMode === 'bw' ? '黑白' : '彩色'}`;
        }
        
        // ============== 计算最佳图像尺寸 ==============
        function calculateOptimalDimensions(pixelsNeeded) {
            if (pixelsNeeded <= 0) {
                return { width: MIN_WIDTH, height: MIN_HEIGHT };
            }
            
            // 首先尝试正方形
            let width = Math.ceil(Math.sqrt(pixelsNeeded));
            let height = Math.ceil(pixelsNeeded / width);
            
            // 调整到接近A4比例
            const targetRatio = ASPECT_RATIO;
            const currentRatio = height / width;
            
            if (currentRatio > targetRatio * 1.2) {
                // 太窄了，增加宽度
                width = Math.ceil(Math.sqrt(pixelsNeeded / targetRatio));
                height = Math.ceil(pixelsNeeded / width);
            } else if (currentRatio < targetRatio / 1.2) {
                // 太宽了，增加高度
                height = Math.ceil(Math.sqrt(pixelsNeeded * targetRatio));
                width = Math.ceil(pixelsNeeded / height);
            }
            
            // 确保在最小和最大范围内
            width = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, width));
            height = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, height));
            
            // 最终检查是否能容纳所有像素
            if (width * height < pixelsNeeded) {
                // 如果不能，增加高度
                height = Math.min(Math.ceil(pixelsNeeded / width), MAX_HEIGHT);
            }
            
            return {
                width: Math.floor(width),
                height: Math.floor(height)
            };
        }
        
        // ============== 计算总字符数 ==============
        function calculateTotalChars(filename, bytes) {
            // 数据格式：头部(5) + 文件名长度(2字符) + 文件名 + 数据长度(2字符) + 文件数据
            
            // 头部标识
            let total = HEADER_MARKER.length;
            
            // 文件名长度（32位整数，需要2个Unicode字符）
            total += 2;
            
            // 文件名本身
            total += filename.length;
            
            // 数据长度（32位整数，需要2个Unicode字符）
            total += 2;
            
            // 文件数据（每个字节作为一个字符）
            total += bytes.length;
            
            return total;
        }
        
        // ============== 更新内存信息 ==============
        function updateMemoryInfo(fileSizeBytes, imageWidth, imageHeight) {
            // 文件内存
            const fileMemoryMB = fileSizeBytes / (1024 * 1024);
            fileMemory.textContent = `${fileMemoryMB.toFixed(2)} MB`;
            
            // 图像内存（RGBA，每个像素4字节）
            const imageMemoryBytes = imageWidth * imageHeight * 4;
            const imageMemoryMB = imageMemoryBytes / (1024 * 1024);
            imageMemory.textContent = `${imageMemoryMB.toFixed(2)} MB`;
            
            // 总内存（加上一些处理开销）
            const totalMemoryBytes = fileSizeBytes + imageMemoryBytes + (10 * 1024 * 1024); // 加上10MB处理开销
            const totalMemoryMB = totalMemoryBytes / (1024 * 1024);
            totalMemory.textContent = `${totalMemoryMB.toFixed(2)} MB`;
            
            // 检查是否超过内存限制
            if (totalMemoryBytes > MAX_MEMORY_BYTES) {
                memoryInfo.className = 'memory-info danger';
                charCount.classList.add('error');
                charCount.textContent += ` (错误: 预计内存使用 ${totalMemoryMB.toFixed(2)} MB，超过 ${(MAX_MEMORY_BYTES / (1024 * 1024)).toFixed(0)} MB 限制)`;
                encodeBtn.disabled = true;
            } else if (totalMemoryBytes > MAX_MEMORY_BYTES * 0.8) {
                memoryInfo.className = 'memory-info warning';
                encodeBtn.disabled = false;
            } else {
                memoryInfo.className = 'memory-info';
                encodeBtn.disabled = false;
            }
        }
        
        // ============== 编码文件为图像 ==============
        function encodeFileToImage() {
            if (!currentFile || !fileData) {
                showNotification('请先选择文件', 'error');
                return;
            }
            
            // 显示加载指示器
            showLoading(true);
            
            // 使用setTimeout避免阻塞UI
            setTimeout(() => {
                try {
                    const bytes = new Uint8Array(fileData);
                    
                    // 构建完整数据
                    const fullData = buildFileData(currentFile.name, bytes);
                    
                    // 计算图像尺寸
                    const totalChars = fullData.length;
                    
                    if (autoSizeEnabled) {
                        // 重新计算最佳尺寸
                        const pixelsRequired = encodingMode === 'bw' ? totalChars * BITS_PER_CHAR_BW : totalChars * 2;
                        const calculated = calculateOptimalDimensions(pixelsRequired);
                        currentWidth = calculated.width;
                        currentHeight = calculated.height;
                    } else {
                        currentWidth = parseInt(imageWidthInput.value) || MIN_WIDTH;
                        currentHeight = parseInt(imageHeightInput.value) || MIN_HEIGHT;
                    }
                    
                    // 检查是否能容纳所有数据
                    const totalPixels = currentWidth * currentHeight;
                    let pixelsRequired = 0;
                    
                    if (encodingMode === 'bw') {
                        pixelsRequired = totalChars * BITS_PER_CHAR_BW;
                    } else {
                        pixelsRequired = totalChars * 2; // 彩色模式每个字符2个像素
                    }
                    
                    if (pixelsRequired > totalPixels) {
                        const neededHeight = Math.ceil(pixelsRequired / currentWidth);
                        throw new Error(`图像太小，无法容纳所有数据。需要至少 ${neededHeight} 像素高度（当前 ${currentHeight}）。`);
                    }
                    
                    // 设置画布尺寸
                    encodedCanvas.width = currentWidth;
                    encodedCanvas.height = currentHeight;
                    
                    // 根据编码模式创建图像
                    if (encodingMode === 'bw') {
                        // 黑白编码
                        createBwImage(fullData);
                    } else {
                        // 彩色编码
                        createColorImage(fullData);
                    }
                    
                    // 显示图像
                    displayEncodedImage();
                    
                    // 更新图像信息
                    updateImageInfo();
                    
                    // 启用下载按钮
                    downloadBtn.disabled = false;
                    
                    // 显示编码成功信息
                    const successMessage = `编码成功！文件 "${currentFile.name}" 已编码为 ${currentWidth}×${currentHeight} 像素的${encodingMode === 'bw' ? '黑白' : '彩色'}图像`;
                    showNotification(successMessage, 'success');
                } catch (error) {
                    console.error('编码错误:', error);
                    showNotification('编码过程中发生错误: ' + error.message, 'error');
                } finally {
                    showLoading(false);
                }
            }, 100);
        }
        
        // ============== 构建文件数据 ==============
        function buildFileData(filename, bytes) {
            // 数据格式：头部标识 + 文件名长度 + 文件名 + 数据长度 + 文件数据
            
            // 头部标识
            let data = HEADER_MARKER;
            
            // 文件名长度（32位整数）
            const filenameLength = filename.length;
            const filenameLengthBinary = encode32BitInteger(filenameLength);
            data += filenameLengthBinary;
            
            // 文件名
            data += filename;
            
            // 数据长度（32位整数）
            const dataLength = bytes.length;
            const dataLengthBinary = encode32BitInteger(dataLength);
            data += dataLengthBinary;
            
            // 文件数据（每个字节作为一个字符）
            for (let i = 0; i < bytes.length; i++) {
                data += String.fromCharCode(bytes[i]);
            }
            
            return data;
        }
        
        // ============== 编码32位整数为2个Unicode字符 ==============
        function encode32BitInteger(value) {
            // 将32位整数编码为2个Unicode字符（21位×2=42位 > 32位）
            const high = (value >>> 21) & 0x7FF; // 高11位
            const low = value & 0x1FFFFF; // 低21位
            
            // 转换为两个Unicode字符
            return String.fromCodePoint(low) + String.fromCodePoint(high);
        }
        
        // ============== 解码2个Unicode字符为32位整数 ==============
        function decode32BitInteger(str) {
            if (str.length < 2) return 0;
            
            const low = str.codePointAt(0);
            const high = str.codePointAt(1);
            
            return (high << 21) | low;
        }
        
        // ============== 创建黑白图像 ==============
        function createBwImage(fullData) {
            const ctx = encodedCanvas.getContext('2d');
            const imageData = ctx.createImageData(currentWidth, currentHeight);
            const data = imageData.data;
            
            // 用白色填充整个画布
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255;     // R
                data[i+1] = 255;   // G
                data[i+2] = 255;   // B
                data[i+3] = 255;   // A
            }
            
            // 将数据编码为二进制并设置像素
            let pixelIndex = 0;
            
            for (let i = 0; i < fullData.length; i++) {
                const charCode = fullData.codePointAt(i);
                
                // 将字符编码为21位二进制
                let binary = charCode.toString(2);
                
                // 填充到21位
                while (binary.length < BITS_PER_CHAR_BW) {
                    binary = '0' + binary;
                }
                
                // 设置像素
                for (let bit = 0; bit < binary.length; bit++) {
                    if (pixelIndex >= currentWidth * currentHeight) break;
                    
                    const baseIndex = pixelIndex * 4;
                    const bitValue = binary[bit];
                    
                    if (bitValue === '1') {
                        data[baseIndex] = 0;     // R
                        data[baseIndex+1] = 0;   // G
                        data[baseIndex+2] = 0;   // B
                    }
                    
                    pixelIndex++;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // ============== 创建彩色图像 ==============
        function createColorImage(fullData) {
            const ctx = encodedCanvas.getContext('2d');
            const imageData = ctx.createImageData(currentWidth, currentHeight);
            const data = imageData.data;
            
            // 用白色填充整个画布
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255;     // R
                data[i+1] = 255;   // G
                data[i+2] = 255;   // B
                data[i+3] = 255;   // A
            }
            
            // 将数据编码为十六进制并设置像素
            let pixelIndex = 0;
            
            for (let i = 0; i < fullData.length; i++) {
                const charCode = fullData.codePointAt(i);
                
                // 将字符编码为6位十六进制（24位）
                let hex = charCode.toString(16);
                
                // 填充到6位十六进制
                while (hex.length < 6) {
                    hex = '0' + hex;
                }
                
                // 每2位十六进制对应一个像素
                for (let j = 0; j < 6; j += 3) {
                    if (pixelIndex >= currentWidth * currentHeight) break;
                    
                    const baseIndex = pixelIndex * 4;
                    
                    // 提取RGB值
                    const rHex = hex[j];
                    const gHex = hex[j+1];
                    const bHex = hex[j+2];
                    
                    // 转换为RGB值
                    const r = HEX_TO_RGB[rHex.toLowerCase()] || 0;
                    const g = HEX_TO_RGB[gHex.toLowerCase()] || 0;
                    const b = HEX_TO_RGB[bHex.toLowerCase()] || 0;
                    
                    data[baseIndex] = r;     // R
                    data[baseIndex+1] = g;   // G
                    data[baseIndex+2] = b;   // B
                    
                    pixelIndex++;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // ============== 显示编码后的图像 ==============
        function displayEncodedImage() {
            // 隐藏占位符，显示canvas
            imageOutput.style.display = 'none';
            encodedCanvas.style.display = 'block';
        }
        
        // ============== 更新图像信息 ==============
        function updateImageInfo() {
            imageDimensions.textContent = `图像尺寸: ${currentWidth}×${currentHeight} 像素`;
            
            // 估计文件大小（PNG格式）
            const estimatedSizeKB = Math.round((currentWidth * currentHeight * (encodingMode === 'bw' ? 0.1 : 0.3)) / 1024);
            imageSize.textContent = `文件大小: ~${estimatedSizeKB} KB`;
        }
        
        // ============== 下载图像 ==============
        function downloadImage() {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            
            const modeSuffix = encodingMode === 'bw' ? 'bw' : 'color';
            link.download = `encoded-${modeSuffix}-${currentFile.name.replace(/\.[^/.]+$/, "")}-${timestamp}.png`;
            link.href = encodedCanvas.toDataURL('image/png');
            link.click();
            showNotification('图像下载成功！', 'success');
        }
        
        // ============== 预览编码图像 ==============
        function previewEncodedImage(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // 设置canvas尺寸
                    decodedCanvas.width = img.width;
                    decodedCanvas.height = img.height;
                    const ctx = decodedCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // 显示图像
                    decodedImagePlaceholder.style.display = 'none';
                    decodedCanvas.style.display = 'block';
                    
                    // 更新检测到的图像尺寸
                    detectedImageSize.textContent = `${img.width}×${img.height} 像素`;
                };
                
                img.onerror = function() {
                    showNotification('无法加载图像文件', 'error');
                };
                
                img.src = e.target.result;
            };
            
            reader.onerror = function() {
                showNotification('无法读取文件', 'error');
            };
            
            reader.readAsDataURL(file);
        }
        
        // ============== 解码图像为文件（优化版） ==============
        function decodeImageToFile() {
            const file = imageInput.files[0];
            if (!file) {
                showNotification('请先选择图像文件', 'error');
                return;
            }
            
            // 显示增强的加载指示器
            showLoading(true, '正在加载并分析图像...');
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    try {
                        // 创建临时canvas（优化性能）
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                        
                        // 绘制图像
                        tempCtx.drawImage(img, 0, 0);
                        
                        // 自动检测编码模式
                        const detectedMode = autoDetectEncodingMode(tempCtx, img.width, img.height);
                        if (detectedMode) {
                            setDecodeMode(detectedMode);
                            showNotification(`自动检测到${detectedMode === 'bw' ? '黑白' : '彩色'}编码模式`, 'info');
                        }
                        
                        // 获取像素数据（使用更高效的方式）
                        showLoading(true, `正在提取${decodeMode === 'bw' ? '黑白' : '彩色'}像素数据...`);
                        
                        setTimeout(() => {
                            try {
                                const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
                                const data = imageData.data;
                                
                                // 根据解码模式提取数据
                                let text = '';
                                
                                if (decodeMode === 'bw') {
                                    showLoading(true, '正在解码黑白图像...', img.width * img.height);
                                    text = decodeBwImage(data, img.width, img.height);
                                } else {
                                    showLoading(true, '正在解码彩色图像...', img.width * img.height);
                                    text = decodeColorImage(data, img.width, img.height);
                                }
                                
                                // 解析文件数据
                                const fileInfo = parseFileData(text);
                                
                                if (!fileInfo) {
                                    // 尝试另一种解码方式
                                    showNotification('标准解码失败，尝试容错解码...', 'warning');
                                    const altText = decodeWithTolerance(tempCtx, img.width, img.height);
                                    decodedFileInfo = parseFileData(altText);
                                    
                                    if (!decodedFileInfo) {
                                        throw new Error('无法识别文件数据格式，请确认图像未损坏且编码正确');
                                    }
                                } else {
                                    decodedFileInfo = fileInfo;
                                }
                                
                                // 显示解码信息
                                displayDecodedInfo(img, decodedFileInfo);
                                
                                // 显示解码字节预览
                                showBytesPreviewForDecoded(decodedFileInfo.data);
                                
                                // 启用下载文件按钮
                                downloadFileBtn.disabled = false;
                                
                                showNotification(`解码成功！检测到文件: ${decodedFileInfo.filename}`, 'success');
                            } catch (error) {
                                console.error('解码错误:', error);
                                showNotification('解码失败: ' + error.message, 'error');
                            } finally {
                                showLoading(false);
                            }
                        }, 100);
                        
                    } catch (error) {
                        console.error('图像处理错误:', error);
                        showNotification('图像处理失败: ' + error.message, 'error');
                        showLoading(false);
                    }
                };
                
                img.onerror = function() {
                    showNotification('无法加载图像文件', 'error');
                    showLoading(false);
                };
                
                img.src = e.target.result;
            };
            
            reader.onerror = function() {
                showNotification('无法读取文件', 'error');
                showLoading(false);
            };
            
            reader.readAsDataURL(file);
        }
        
        // ============== 解码黑白图像 ==============
        function decodeBwImage(data, width, height) {
            let text = '';
            const totalPixels = width * height;
            
            // 存储所有二进制位
            let binaryBits = '';
            
            for (let i = 0; i < totalPixels; i++) {
                const pixelIndex = i * 4;
                const r = data[pixelIndex];
                const g = data[pixelIndex + 1];
                const b = data[pixelIndex + 2];
                
                // 判断是黑(1)还是白(0)
                const isBlack = (r < 128 && g < 128 && b < 128);
                binaryBits += isBlack ? '1' : '0';
            }
            
            // 每21位转换为一个字符
            for (let i = 0; i < binaryBits.length; i += BITS_PER_CHAR_BW) {
                if (i + BITS_PER_CHAR_BW > binaryBits.length) break;
                
                const binaryChunk = binaryBits.substring(i, i + BITS_PER_CHAR_BW);
                const charCode = parseInt(binaryChunk, 2);
                
                // 跳过无效字符
                if (charCode === 0 && text.length > 0 && !text.endsWith(HEADER_MARKER)) {
                    continue;
                }
                
                text += String.fromCodePoint(charCode);
            }
            
            return text;
        }
        
        // ============== 解码彩色图像 ==============
        function decodeColorImage(data, width, height) {
            let text = '';
            const totalPixels = width * height;
            
            // 颜色误差容错范围（0-255）
            const TOLERANCE = 8;
            
            // RGB到十六进制的容错转换函数
            function rgbToHexWithTolerance(rgbValue) {
                // 将RGB值近似到最近的17的倍数（0,17,34,...,255）
                const normalized = Math.round(rgbValue / 17) * 17;
                // 确保在0-255范围内
                const clamped = Math.max(0, Math.min(255, normalized));
                // 转换回十六进制
                const hexValue = Math.round(clamped / 17);
                return hexValue.toString(16);
            }
            
            showLoading(true, '正在解码彩色图像...', totalPixels);
            
            // 每2个像素对应一个字符（6位十六进制）
            for (let i = 0; i < totalPixels; i += 2) {
                if (i + 1 >= totalPixels) break;
                
                // 更新进度
                if (i % 1000 === 0) {
                    updateDecodeProgress(i, totalPixels, '彩色');
                }
                
                // 获取第一个像素
                const pixelIndex1 = i * 4;
                const r1 = data[pixelIndex1];
                const g1 = data[pixelIndex1 + 1];
                const b1 = data[pixelIndex1 + 2];
                
                // 获取第二个像素
                const pixelIndex2 = (i + 1) * 4;
                const r2 = data[pixelIndex2];
                const g2 = data[pixelIndex2 + 1];
                const b2 = data[pixelIndex2 + 2];
                
                // 使用容错转换
                const hex1 = rgbToHexWithTolerance(r1);
                const hex2 = rgbToHexWithTolerance(g1);
                const hex3 = rgbToHexWithTolerance(b1);
                const hex4 = rgbToHexWithTolerance(r2);
                const hex5 = rgbToHexWithTolerance(g2);
                const hex6 = rgbToHexWithTolerance(b2);
                
                // 组合成6位十六进制
                const hex = hex1 + hex2 + hex3 + hex4 + hex5 + hex6;
                
                // 转换为字符代码
                const charCode = parseInt(hex, 16);
                
                // 有效性检查
                if (charCode <= MAX_UNICODE) {
                    text += String.fromCodePoint(charCode);
                }
            }
            
            return text;
        }

        
        
        // ============== 显示解码字节预览 ==============
        function showBytesPreviewForDecoded(bytes) {
            const previewCount = Math.min(bytes.length, 1000);
            let previewText = '';
            for (let i = 0; i < previewCount; i++) {
                const byte = bytes[i];
                previewText += byte.toString(16).padStart(2, '0').toUpperCase() + ' ';
                if ((i + 1) % 16 === 0) previewText += '\n';
            }
            decodedBytesPreview.textContent = previewText;
        }
        
        // ============== 解析文件数据 ==============
        function parseFileData(text) {
            // 检查头部标识
            if (!text.startsWith(HEADER_MARKER)) {
                return null;
            }
            
            let index = HEADER_MARKER.length;
            
            // 读取文件名长度
            if (index + 2 > text.length) return null;
            const filenameLengthStr = text.substring(index, index + 2);
            const filenameLength = decode32BitInteger(filenameLengthStr);
            index += 2;
            
            // 读取文件名
            if (index + filenameLength > text.length) return null;
            const filename = text.substring(index, index + filenameLength);
            index += filenameLength;
            
            // 读取数据长度
            if (index + 2 > text.length) return null;
            const dataLengthStr = text.substring(index, index + 2);
            const dataLength = decode32BitInteger(dataLengthStr);
            index += 2;
            
            // 读取文件数据
            if (index + dataLength > text.length) return null;
            
            // 将字符转换回字节
            const bytes = new Uint8Array(dataLength);
            for (let i = 0; i < dataLength; i++) {
                bytes[i] = text.charCodeAt(index + i);
            }
            
            return {
                filename: filename,
                data: bytes,
                size: dataLength
            };
        }
        
        // ============== 下载解码文件 ==============
        function downloadDecodedFile() {
            if (!decodedFileInfo) {
                showNotification('没有可下载的文件', 'error');
                return;
            }
            
            try {
                const blob = new Blob([decodedFileInfo.data]);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                
                a.href = url;
                a.download = decodedFileInfo.filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification(`文件下载成功：${decodedFileInfo.filename}`, 'success');
            } catch (error) {
                showNotification(`下载失败：${error.message}`, 'error');
            }
        }
        
        // ============== 显示/隐藏加载指示器 ==============
        function showLoading(show) {
            if (show) {
                loadingIndicator.classList.add('active');
                encodeBtn.disabled = true;
                decodeBtn.disabled = true;
            } else {
                loadingIndicator.classList.remove('active');
                encodeBtn.disabled = !currentFile;
                decodeBtn.disabled = !imageInput.files.length;
            }
        }
        
        // ============== 显示通知 ==============
        function showNotification(message, type = 'info') {
            notificationMessage.textContent = message;
            notification.className = 'notification';
            notification.classList.add(type);
            
            let iconClass = 'fas fa-info-circle';
            if (type === 'success') iconClass = 'fas fa-check-circle';
            else if (type === 'error') iconClass = 'fas fa-exclamation-circle';
            else if (type === 'warning') iconClass = 'fas fa-exclamation-triangle';
            
            notificationIcon.className = iconClass;
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // ============== 更新解码进度 ==============
        let decodeStartTime = 0;
        let lastProgressUpdate = 0;
        
        function updateDecodeProgress(current, total, mode) {
            const now = Date.now();
            // 限制更新频率（每500ms更新一次）
            if (now - lastProgressUpdate < 500) return;
            
            lastProgressUpdate = now;
            
            const percent = Math.round((current / total) * 100);
            const elapsed = (now - decodeStartTime) / 1000;
            
            // 计算剩余时间
            let remaining = '计算中...';
            if (current > 100) {
                const rate = current / elapsed;
                remaining = Math.round((total - current) / rate) + '秒';
            }
            
            // 更新加载指示器
            const progressText = `${mode}解码进度: ${percent}% | 剩余时间: ${remaining}`;
            updateLoadingMessage(progressText);
        }
        
        // ============== 更新加载消息 ==============
        function updateLoadingMessage(message) {
            const loadingText = document.querySelector('#loadingIndicator p');
            if (loadingText) {
                loadingText.textContent = message;
            }
        }
        
        // ============== 增强的显示加载函数 ==============
        function showLoading(show, message = '正在处理中，请稍候...', totalItems = 0) {
            if (show) {
                loadingIndicator.classList.add('active');
                encodeBtn.disabled = true;
                decodeBtn.disabled = true;
                
                // 记录开始时间
                decodeStartTime = Date.now();
                lastProgressUpdate = 0;
                
                // 更新消息
                updateLoadingMessage(message);
                
                // 添加进度条（如果不存在）
                if (!document.getElementById('progressBar')) {
                    const progressHTML = `
                        <div style="width: 80%; margin: 10px auto; background: #333; border-radius: 10px; overflow: hidden;">
                            <div id="progressBar" style="height: 10px; background: #6c63ff; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="progressText" style="font-size: 0.9rem; color: #a0a0c0;"></div>
                    `;
                    loadingIndicator.innerHTML += progressHTML;
                }
            } else {
                loadingIndicator.classList.remove('active');
                encodeBtn.disabled = !currentFile;
                decodeBtn.disabled = !imageInput.files.length;
            }
        }
        
        // ============== 更新进度条 ==============
        function updateProgressBar(percent, text) {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            
            if (progressBar) {
                progressBar.style.width = percent + '%';
            }
            if (progressText) {
                progressText.textContent = text;
            }
        }
        
        // ============== 辅助函数 ==============
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function getFileExtension(filename) {
            const ext = filename.slice((filename.lastIndexOf(".") - 1 >>> 0) + 2);
            return ext ? ext.toUpperCase() + ' 文件' : '未知类型';
        }
        
        // ============== 更新宽高比显示 ==============
        function updateAspectRatio() {
            const width = parseInt(imageWidthInput.value) || MIN_WIDTH;
            const height = parseInt(imageHeightInput.value) || MIN_HEIGHT;
            const ratio = (height / width).toFixed(3);
            aspectRatioInput.value = `1:${ratio}`;
        }
        
        // ============== 键盘快捷键 ==============
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ctrl+E 编码
                if (e.ctrlKey && e.key === 'e') {
                    if (!encodeBtn.disabled) {
                        encodeFileToImage();
                        e.preventDefault();
                    }
                }
                
                // Ctrl+D 解码
                if (e.ctrlKey && e.key === 'd') {
                    if (!decodeBtn.disabled) {
                        decodeImageToFile();
                        e.preventDefault();
                    }
                }
                
                // Ctrl+B 切换到黑白模式
                if (e.ctrlKey && e.key === 'b') {
                    setEncodingMode('bw');
                    e.preventDefault();
                }
                
                // Ctrl+C 切换到彩色模式
                if (e.ctrlKey && e.key === 'c') {
                    setEncodingMode('color');
                    e.preventDefault();
                }
            });
        }
        
        // ============== 控制台信息 ==============
        console.log('%c🔐 文件↔图像转换器（黑白/彩色编码版）v2.0 %c已加载完成！', 
            'color: #6c63ff; font-size: 16px; font-weight: bold;', 
            'color: #4caf50; font-size: 14px;');
        console.log('%c📋 功能特性:', 'color: #2196f3; font-weight: bold;');
        console.log('- 支持黑白和彩色两种编码模式');
        console.log('- 黑白模式：21位/字符，1像素/位');
        console.log('- 彩色模式：6位十六进制/字符，2像素/字符');
        console.log('- 自动调整图像尺寸，修复了尺寸计算问题');
        console.log('- 内存使用监控和提示');
        console.log('%c⌨️ 快捷键:', 'color: #ff9800; font-weight: bold;');
        console.log('Ctrl+E: 编码文件');
        console.log('Ctrl+D: 解码图像');
        console.log('Ctrl+B: 黑白模式');
        console.log('Ctrl+C: 彩色模式');
    </script>
</body>
</html>
